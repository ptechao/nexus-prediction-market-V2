/**\n * Oracle 聚合器服務\n * \n * 聚合多個 Oracle 數據源的價格數據，進行驗證和清理，計算中位數。\n */\n\nimport { ethers } from 'ethers';\n\n/**\n * Oracle 數據源配置\n */\ninterface OracleSource {\n  name: string;\n  address: string;\n  weight: number; // 權重 (0-1)\n  timeout: number; // 超時時間 (毫秒)\n  maxDeviation: number; // 最大偏差 (%)\n}\n\n/**\n * Oracle 價格數據\n */\ninterface OraclePrice {\n  source: string;\n  price: bigint; // Wei\n  timestamp: number;\n  confidence: number; // 0-1\n  valid: boolean;\n}\n\n/**\n * 聚合結果\n */\ninterface AggregationResult {\n  medianPrice: bigint;\n  meanPrice: bigint;\n  minPrice: bigint;\n  maxPrice: bigint;\n  standardDeviation: bigint;\n  confidence: number;\n  sources: number; // 有效數據源數量\n  timestamp: number;\n}\n\n/**\n * Oracle 聚合器\n */\nclass OracleAggregator {\n  private sources: Map<string, OracleSource> = new Map();\n  private priceCache: Map<string, OraclePrice> = new Map();\n  private cacheTTL: number = 60000; // 1 分鐘\n  private lastUpdateTime: Map<string, number> = new Map();\n\n  /**\n   * 註冊 Oracle 數據源\n   */\n  registerSource(source: OracleSource): void {\n    if (source.weight < 0 || source.weight > 1) {\n      throw new Error('Weight must be between 0 and 1');\n    }\n    this.sources.set(source.name, source);\n  }\n\n  /**\n   * 註銷 Oracle 數據源\n   */\n  unregisterSource(name: string): void {\n    this.sources.delete(name);\n    this.priceCache.delete(name);\n    this.lastUpdateTime.delete(name);\n  }\n\n  /**\n   * 從單個 Oracle 獲取價格\n   */\n  private async fetchFromSource(source: OracleSource): Promise<OraclePrice | null> {\n    try {\n      // 模擬 Oracle 調用（實際應調用真實 Oracle）\n      const price = await this.mockOracleCall(source);\n\n      const oraclePrice: OraclePrice = {\n        source: source.name,\n        price,\n        timestamp: Date.now(),\n        confidence: 0.95,\n        valid: true,\n      };\n\n      // 緩存價格\n      this.priceCache.set(source.name, oraclePrice);\n      this.lastUpdateTime.set(source.name, Date.now());\n\n      return oraclePrice;\n    } catch (error) {\n      console.error(`Failed to fetch from ${source.name}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * 模擬 Oracle 調用\n   * 實際應調用真實的 Oracle 合約或 API\n   */\n  private async mockOracleCall(source: OracleSource): Promise<bigint> {\n    // 模擬網絡延遲\n    await new Promise((resolve) => setTimeout(resolve, Math.random() * 100));\n\n    // 返回模擬價格（例如 $50,000 = 50000 * 10^18 Wei）\n    const basePrice = 50000n * 10n ** 18n;\n    const variation = BigInt(Math.floor(Math.random() * 1000 - 500)); // ±500\n    return basePrice + variation;\n  }\n\n  /**\n   * 驗證價格數據\n   */\n  private validatePrice(price: OraclePrice, referencePrice: bigint): boolean {\n    if (!price.valid) return false;\n\n    // 檢查時間戳（不超過 5 分鐘）\n    if (Date.now() - price.timestamp > 5 * 60 * 1000) {\n      return false;\n    }\n\n    // 檢查偏差\n    const deviation = this.calculateDeviation(price.price, referencePrice);\n    const source = this.sources.get(price.source);\n    if (source && Math.abs(deviation) > source.maxDeviation) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * 計算偏差百分比\n   */\n  private calculateDeviation(price: bigint, reference: bigint): number {\n    if (reference === 0n) return 0;\n    const diff = Number(price - reference);\n    const ref = Number(reference);\n    return (diff / ref) * 100;\n  }\n\n  /**\n   * 計算中位數\n   */\n  private calculateMedian(prices: bigint[]): bigint {\n    if (prices.length === 0) throw new Error('No prices to calculate median');\n\n    const sorted = [...prices].sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));\n    const mid = Math.floor(sorted.length / 2);\n\n    if (sorted.length % 2 === 0) {\n      return (sorted[mid - 1] + sorted[mid]) / 2n;\n    }\n    return sorted[mid];\n  }\n\n  /**\n   * 計算平均值\n   */\n  private calculateMean(prices: bigint[]): bigint {\n    if (prices.length === 0) throw new Error('No prices to calculate mean');\n    const sum = prices.reduce((a, b) => a + b, 0n);\n    return sum / BigInt(prices.length);\n  }\n\n  /**\n   * 計算標準差\n   */\n  private calculateStandardDeviation(prices: bigint[], mean: bigint): bigint {\n    if (prices.length === 0) throw new Error('No prices to calculate standard deviation');\n\n    const squaredDiffs = prices.map((price) => {\n      const diff = price - mean;\n      return diff * diff;\n    });\n\n    const variance = squaredDiffs.reduce((a, b) => a + b, 0n) / BigInt(prices.length);\n    // 簡化：返回方差的平方根（近似）\n    return variance;\n  }\n\n  /**\n   * 聚合多個 Oracle 的價格\n   */\n  async aggregatePrice(marketId: string): Promise<AggregationResult> {\n    const sources = Array.from(this.sources.values());\n    if (sources.length === 0) {\n      throw new Error('No Oracle sources registered');\n    }\n\n    // 並行從所有 Oracle 獲取價格\n    const pricePromises = sources.map((source) => this.fetchFromSource(source));\n    const prices = await Promise.all(pricePromises);\n\n    // 過濾有效價格\n    const validPrices = prices.filter((p) => p !== null) as OraclePrice[];\n    if (validPrices.length === 0) {\n      throw new Error('No valid prices from any Oracle source');\n    }\n\n    // 計算參考價格（初始中位數）\n    const referencePrices = validPrices.map((p) => p.price);\n    const referencePrice = this.calculateMedian(referencePrices);\n\n    // 驗證價格\n    const verifiedPrices = validPrices.filter((p) => this.validatePrice(p, referencePrice));\n    if (verifiedPrices.length === 0) {\n      throw new Error('All prices failed validation');\n    }\n\n    // 提取驗證通過的價格\n    const finalPrices = verifiedPrices.map((p) => p.price);\n\n    // 計算統計指標\n    const medianPrice = this.calculateMedian(finalPrices);\n    const meanPrice = this.calculateMean(finalPrices);\n    const minPrice = finalPrices.reduce((a, b) => (a < b ? a : b));\n    const maxPrice = finalPrices.reduce((a, b) => (a > b ? a : b));\n    const standardDeviation = this.calculateStandardDeviation(finalPrices, meanPrice);\n\n    // 計算置信度\n    const confidence = this.calculateConfidence(\n      verifiedPrices.length,\n      sources.length,\n      standardDeviation,\n      meanPrice\n    );\n\n    return {\n      medianPrice,\n      meanPrice,\n      minPrice,\n      maxPrice,\n      standardDeviation,\n      confidence,\n      sources: verifiedPrices.length,\n      timestamp: Date.now(),\n    };\n  }\n\n  /**\n   * 計算置信度\n   */\n  private calculateConfidence(\n    validSources: number,\n    totalSources: number,\n    stdDev: bigint,\n    mean: bigint\n  ): number {\n    // 基於有效數據源數量\n    const sourceConfidence = validSources / totalSources;\n\n    // 基於標準差（越小越好）\n    const coefficientOfVariation =\n      mean === 0n ? 0 : Number(stdDev) / Number(mean);\n    const stdDevConfidence = Math.max(0, 1 - coefficientOfVariation);\n\n    // 加權平均\n    return sourceConfidence * 0.6 + stdDevConfidence * 0.4;\n  }\n\n  /**\n   * 檢測異常價格\n   */\n  detectAnomalies(prices: OraclePrice[]): OraclePrice[] {\n    if (prices.length < 3) return [];\n\n    const priceValues = prices.map((p) => p.price);\n    const median = this.calculateMedian(priceValues);\n\n    // 使用 IQR 方法檢測異常\n    const sorted = [...priceValues].sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));\n    const q1Index = Math.floor(sorted.length * 0.25);\n    const q3Index = Math.floor(sorted.length * 0.75);\n    const q1 = sorted[q1Index];\n    const q3 = sorted[q3Index];\n    const iqr = q3 - q1;\n\n    const lowerBound = q1 - 1.5n * iqr;\n    const upperBound = q3 + 1.5n * iqr;\n\n    return prices.filter((p) => p.price < lowerBound || p.price > upperBound);\n  }\n\n  /**\n   * 清理過期的緩存\n   */\n  cleanupCache(): void {\n    const now = Date.now();\n    for (const [source, lastUpdate] of this.lastUpdateTime.entries()) {\n      if (now - lastUpdate > this.cacheTTL) {\n        this.priceCache.delete(source);\n        this.lastUpdateTime.delete(source);\n      }\n    }\n  }\n\n  /**\n   * 獲取緩存的價格\n   */\n  getCachedPrice(source: string): OraclePrice | null {\n    const price = this.priceCache.get(source);\n    if (!price) return null;\n\n    const lastUpdate = this.lastUpdateTime.get(source) || 0;\n    if (Date.now() - lastUpdate > this.cacheTTL) {\n      this.priceCache.delete(source);\n      return null;\n    }\n\n    return price;\n  }\n\n  /**\n   * 獲取所有已註冊的 Oracle 源\n   */\n  getSources(): OracleSource[] {\n    return Array.from(this.sources.values());\n  }\n\n  /**\n   * 獲取統計信息\n   */\n  getStats() {\n    return {\n      registeredSources: this.sources.size,\n      cachedPrices: this.priceCache.size,\n      sources: Array.from(this.sources.keys()),\n    };\n  }\n}\n\n// 導出單例\nconst oracleAggregator = new OracleAggregator();\n\n// 註冊默認 Oracle 源\noracleAggregator.registerSource({\n  name: 'Chainlink',\n  address: '0x' + 'a'.repeat(40),\n  weight: 0.4,\n  timeout: 5000,\n  maxDeviation: 5, // 5%\n});\n\noracleAggregator.registerSource({\n  name: 'Pyth',\n  address: '0x' + 'b'.repeat(40),\n  weight: 0.3,\n  timeout: 5000,\n  maxDeviation: 5,\n});\n\noracleAggregator.registerSource({\n  name: 'Band Protocol',\n  address: '0x' + 'c'.repeat(40),\n  weight: 0.3,\n  timeout: 5000,\n  maxDeviation: 5,\n});\n\nexport default oracleAggregator;\nexport type { OracleSource, OraclePrice, AggregationResult };\n
