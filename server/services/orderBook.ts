/**\n * Order Book 服務\n * \n * 訂單簿管理、訂單匹配、價格發現、流動性管理\n */\n\nimport Decimal from 'decimal.js';\nimport { Order, OrderType, OrderStatus } from './tradingEngine';\n\n/**\n * 訂單簿層級\n */\ninterface OrderBookLevel {\n  price: Decimal;\n  quantity: Decimal;\n  orders: Order[];\n}\n\n/**\n * 訂單簿\n */\ninterface OrderBookSnapshot {\n  marketId: string;\n  timestamp: number;\n  bids: OrderBookLevel[];\n  asks: OrderBookLevel[];\n  midPrice: Decimal;\n  spread: Decimal;\n  spreadPercent: Decimal;\n}\n\n/**\n * 匹配結果\n */\ninterface MatchResult {\n  matched: boolean;\n  buyOrder: Order;\n  sellOrder: Order;\n  matchPrice: Decimal;\n  matchQuantity: Decimal;\n}\n\n/**\n * Order Book 服務\n */\nexport class OrderBook {\n  private bids: Map<string, OrderBookLevel[]> = new Map(); // 買單\n  private asks: Map<string, OrderBookLevel[]> = new Map(); // 賣單\n  private orderToLevel: Map<string, { marketId: string; side: 'bid' | 'ask'; index: number }> = new Map();\n  private maxLevels: number = 100; // 最多保留 100 個價格層級\n  private matchListeners: ((result: MatchResult) => void)[] = [];\n\n  /**\n   * 添加訂單到訂單簿\n   */\n  addOrder(order: Order): void {\n    if (!this.bids.has(order.marketId)) {\n      this.bids.set(order.marketId, []);\n      this.asks.set(order.marketId, []);\n    }\n\n    const side = order.type === OrderType.BUY_YES || order.type === OrderType.BUY_NO ? 'bid' : 'ask';\n    const levels = side === 'bid' ? this.bids.get(order.marketId)! : this.asks.get(order.marketId)!;\n\n    // 查找或創建價格層級\n    let level = levels.find((l) => l.price.equals(order.price));\n    if (!level) {\n      level = {\n        price: order.price,\n        quantity: new Decimal('0'),\n        orders: [],\n      };\n      levels.push(level);\n      levels.sort((a, b) => {\n        if (side === 'bid') {\n          return b.price.comparedTo(a.price); // 買單按價格降序\n        } else {\n          return a.price.comparedTo(b.price); // 賣單按價格升序\n        }\n      });\n    }\n\n    // 添加訂單到層級\n    level.orders.push(order);\n    level.quantity = level.quantity.plus(order.shares);\n\n    // 記錄訂單到層級的映射\n    const index = levels.indexOf(level);\n    this.orderToLevel.set(order.id, { marketId: order.marketId, side, index });\n\n    // 嘗試匹配訂單\n    this.matchOrders(order.marketId);\n  }\n\n  /**\n   * 移除訂單\n   */\n  removeOrder(orderId: string): boolean {\n    const mapping = this.orderToLevel.get(orderId);\n    if (!mapping) return false;\n\n    const { marketId, side, index } = mapping;\n    const levels = side === 'bid' ? this.bids.get(marketId)! : this.asks.get(marketId)!;\n    const level = levels[index];\n\n    if (!level) return false;\n\n    const orderIndex = level.orders.findIndex((o) => o.id === orderId);\n    if (orderIndex === -1) return false;\n\n    const order = level.orders[orderIndex];\n    level.orders.splice(orderIndex, 1);\n    level.quantity = level.quantity.minus(order.shares);\n\n    // 如果層級為空，移除它\n    if (level.orders.length === 0) {\n      levels.splice(index, 1);\n    }\n\n    this.orderToLevel.delete(orderId);\n    return true;\n  }\n\n  /**\n   * 匹配訂單\n   */\n  private matchOrders(marketId: string): void {\n    const bids = this.bids.get(marketId) || [];\n    const asks = this.asks.get(marketId) || [];\n\n    if (bids.length === 0 || asks.length === 0) return;\n\n    // 獲取最優買賣單\n    const bestBid = bids[0];\n    const bestAsk = asks[0];\n\n    // 檢查是否可以匹配\n    if (bestBid.price.lessThan(bestAsk.price)) return;\n\n    // 匹配價格（取中間值）\n    const matchPrice = bestBid.price.plus(bestAsk.price).dividedBy(2);\n\n    // 匹配數量（取最小值）\n    const matchQuantity = Decimal.min(bestBid.quantity, bestAsk.quantity);\n\n    // 執行匹配\n    for (const buyOrder of bestBid.orders) {\n      for (const sellOrder of bestAsk.orders) {\n        if (buyOrder.filledShares.greaterThanOrEqualTo(buyOrder.shares)) continue;\n        if (sellOrder.filledShares.greaterThanOrEqualTo(sellOrder.shares)) continue;\n\n        const buyRemaining = buyOrder.shares.minus(buyOrder.filledShares);\n        const sellRemaining = sellOrder.shares.minus(sellOrder.filledShares);\n        const quantity = Decimal.min(buyRemaining, sellRemaining);\n\n        // 更新訂單\n        buyOrder.filledShares = buyOrder.filledShares.plus(quantity);\n        buyOrder.filledAmount = buyOrder.filledAmount.plus(quantity.times(matchPrice));\n        if (buyOrder.filledShares.equals(buyOrder.shares)) {\n          buyOrder.status = OrderStatus.FILLED;\n        } else {\n          buyOrder.status = OrderStatus.PARTIALLY_FILLED;\n        }\n\n        sellOrder.filledShares = sellOrder.filledShares.plus(quantity);\n        sellOrder.filledAmount = sellOrder.filledAmount.plus(quantity.times(matchPrice));\n        if (sellOrder.filledShares.equals(sellOrder.shares)) {\n          sellOrder.status = OrderStatus.FILLED;\n        } else {\n          sellOrder.status = OrderStatus.PARTIALLY_FILLED;\n        }\n\n        // 通知監聽器\n        const result: MatchResult = {\n          matched: true,\n          buyOrder,\n          sellOrder,\n          matchPrice,\n          matchQuantity: quantity,\n        };\n        this.notifyMatchListeners(result);\n      }\n    }\n\n    // 清理已完全成交的訂單\n    this.cleanupFilledOrders(marketId);\n  }\n\n  /**\n   * 清理已完全成交的訂單\n   */\n  private cleanupFilledOrders(marketId: string): void {\n    const bids = this.bids.get(marketId) || [];\n    const asks = this.asks.get(marketId) || [];\n\n    for (const levels of [bids, asks]) {\n      for (const level of levels) {\n        level.orders = level.orders.filter((o) => o.status !== OrderStatus.FILLED);\n        level.quantity = level.orders.reduce((sum, o) => sum.plus(o.shares.minus(o.filledShares)), new Decimal('0'));\n      }\n    }\n  }\n\n  /**\n   * 獲取訂單簿快照\n   */\n  getSnapshot(marketId: string, depth: number = 10): OrderBookSnapshot {\n    const bids = (this.bids.get(marketId) || []).slice(0, depth);\n    const asks = (this.asks.get(marketId) || []).slice(0, depth);\n\n    const midPrice =\n      bids.length > 0 && asks.length > 0\n        ? bids[0].price.plus(asks[0].price).dividedBy(2)\n        : bids.length > 0\n          ? bids[0].price\n          : asks.length > 0\n            ? asks[0].price\n            : new Decimal('0.5');\n\n    const spread =\n      bids.length > 0 && asks.length > 0 ? asks[0].price.minus(bids[0].price) : new Decimal('0');\n\n    const spreadPercent =\n      midPrice.greaterThan(0) && spread.greaterThan(0)\n        ? spread.dividedBy(midPrice).times(100)\n        : new Decimal('0');\n\n    return {\n      marketId,\n      timestamp: Date.now(),\n      bids,\n      asks,\n      midPrice,\n      spread,\n      spreadPercent,\n    };\n  }\n\n  /**\n   * 獲取最優買賣價\n   */\n  getBestPrices(marketId: string): { bid: Decimal; ask: Decimal } | null {\n    const bids = this.bids.get(marketId) || [];\n    const asks = this.asks.get(marketId) || [];\n\n    if (bids.length === 0 || asks.length === 0) return null;\n\n    return {\n      bid: bids[0].price,\n      ask: asks[0].price,\n    };\n  }\n\n  /**\n   * 獲取流動性深度\n   */\n  getLiquidityDepth(marketId: string, levels: number = 5): { bid: Decimal; ask: Decimal } {\n    const bids = this.bids.get(marketId) || [];\n    const asks = this.asks.get(marketId) || [];\n\n    const bidDepth = bids\n      .slice(0, levels)\n      .reduce((sum, level) => sum.plus(level.quantity), new Decimal('0'));\n    const askDepth = asks\n      .slice(0, levels)\n      .reduce((sum, level) => sum.plus(level.quantity), new Decimal('0'));\n\n    return { bid: bidDepth, ask: askDepth };\n  }\n\n  /**\n   * 註冊匹配監聽器\n   */\n  onMatch(listener: (result: MatchResult) => void): void {\n    this.matchListeners.push(listener);\n  }\n\n  /**\n   * 移除匹配監聽器\n   */\n  offMatch(listener: (result: MatchResult) => void): void {\n    const index = this.matchListeners.indexOf(listener);\n    if (index !== -1) {\n      this.matchListeners.splice(index, 1);\n    }\n  }\n\n  /**\n   * 通知匹配監聽器\n   */\n  private notifyMatchListeners(result: MatchResult): void {\n    for (const listener of this.matchListeners) {\n      try {\n        listener(result);\n      } catch (error) {\n        console.error('[Order Book] Error in match listener:', error);\n      }\n    }\n  }\n\n  /**\n   * 獲取統計信息\n   */\n  getStats() {\n    let totalBids = 0;\n    let totalAsks = 0;\n    let totalBidVolume = new Decimal('0');\n    let totalAskVolume = new Decimal('0');\n\n    for (const levels of this.bids.values()) {\n      totalBids += levels.length;\n      for (const level of levels) {\n        totalBidVolume = totalBidVolume.plus(level.quantity);\n      }\n    }\n\n    for (const levels of this.asks.values()) {\n      totalAsks += levels.length;\n      for (const level of levels) {\n        totalAskVolume = totalAskVolume.plus(level.quantity);\n      }\n    }\n\n    return {\n      bidLevels: totalBids,\n      askLevels: totalAsks,\n      bidVolume: totalBidVolume.toString(),\n      askVolume: totalAskVolume.toString(),\n      markets: this.bids.size,\n    };\n  }\n}\n\n// 導出單例\nexport const orderBook = new OrderBook();\nexport type { OrderBookLevel, OrderBookSnapshot, MatchResult };\n
