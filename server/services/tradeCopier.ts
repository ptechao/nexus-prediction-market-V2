/**\n * Trade Copier 服務\n * \n * 交易複製、訂單複製、風險調整、費用計算\n */\n\nimport Decimal from 'decimal.js';\nimport { Order, OrderType } from './tradingEngine';\n\n/**\n * 複製交易\n */\nexport interface CopiedTrade {\n  id: string;\n  originalOrderId: string; // 原始訂單 ID\n  relationId: string; // 跟隨關係 ID\n  followerId: string; // 跟隨者 ID\n  traderOrderId: string; // Trader 訂單 ID\n  type: OrderType;\n  originalShares: Decimal; // 原始份額\n  copiedShares: Decimal; // 複製份額\n  originalPrice: Decimal; // 原始價格\n  copiedPrice: Decimal; // 複製價格\n  scaleFactor: Decimal; // 縮放因子\n  status: 'pending' | 'executed' | 'failed' | 'cancelled';\n  pnL: Decimal; // 損益\n  fee: Decimal; // 費用\n  createdAt: number;\n  executedAt?: number;\n}\n\n/**\n * 複製統計\n */\nexport interface CopyStats {\n  relationId: string;\n  totalCopied: number; // 總複製交易數\n  successful: number; // 成功複製數\n  failed: number; // 失敗複製數\n  totalPnL: Decimal; // 總損益\n  totalFee: Decimal; // 總費用\n  averageScaleFactor: Decimal; // 平均縮放因子\n  lastCopyTime: number;\n}\n\n/**\n * Trade Copier 服務\n */\nexport class TradeCopier {\n  private copiedTrades: Map<string, CopiedTrade[]> = new Map();\n  private copyStats: Map<string, CopyStats> = new Map();\n  private copyListeners: ((trade: CopiedTrade) => void)[] = [];\n  private copyFeeRate: Decimal = new Decimal('0.02'); // 2% 複製費\n  private maxCopyDelay: number = 5000; // 最多延遲 5 秒\n  private minScaleFactor: Decimal = new Decimal('0.1'); // 最小縮放 10%\n  private maxScaleFactor: Decimal = new Decimal('1'); // 最大縮放 100%\n\n  /**\n   * 複製交易\n   */\n  copyTrade(\n    relationId: string,\n    followerId: string,\n    traderOrder: Order,\n    followerBalance: Decimal,\n    followerAllocation: Decimal,\n    followerSettings: any\n  ): { copiedTradeId: string; copiedShares: Decimal; error?: string } {\n    // 驗證跟隨關係\n    if (!relationId || !followerId) {\n      return { copiedTradeId: '', copiedShares: new Decimal('0'), error: 'Invalid follow relation' };\n    }\n\n    // 驗證 Trader 訂單\n    if (!traderOrder || !traderOrder.shares || traderOrder.shares.equals(0)) {\n      return { copiedTradeId: '', copiedShares: new Decimal('0'), error: 'Invalid trader order' };\n    }\n\n    // 計算縮放因子\n    const scaleFactor = this.calculateScaleFactor(\n      traderOrder.amount,\n      followerBalance,\n      followerAllocation,\n      followerSettings\n    );\n\n    if (scaleFactor.lessThan(this.minScaleFactor)) {\n      return { copiedTradeId: '', copiedShares: new Decimal('0'), error: 'Insufficient balance to copy trade' };\n    }\n\n    // 計算複製份額和金額\n    const copiedShares = traderOrder.shares.times(scaleFactor);\n    const copiedAmount = traderOrder.amount.times(scaleFactor);\n\n    // 驗證複製金額\n    if (copiedAmount.greaterThan(followerBalance)) {\n      return { copiedTradeId: '', copiedShares: new Decimal('0'), error: 'Insufficient balance' };\n    }\n\n    if (copiedAmount.lessThan(followerSettings.minTradeSize)) {\n      return { copiedTradeId: '', copiedShares: new Decimal('0'), error: 'Trade size too small' };\n    }\n\n    if (copiedAmount.greaterThan(followerSettings.maxTradeSize)) {\n      return { copiedTradeId: '', copiedShares: new Decimal('0'), error: 'Trade size too large' };\n    }\n\n    // 計算費用\n    const fee = copiedAmount.times(this.copyFeeRate);\n\n    // 創建複製交易\n    const copiedTradeId = `copy-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    const copiedTrade: CopiedTrade = {\n      id: copiedTradeId,\n      originalOrderId: traderOrder.id,\n      relationId,\n      followerId,\n      traderOrderId: traderOrder.id,\n      type: traderOrder.type,\n      originalShares: traderOrder.shares,\n      copiedShares,\n      originalPrice: traderOrder.price,\n      copiedPrice: traderOrder.price,\n      scaleFactor,\n      status: 'pending',\n      pnL: new Decimal('0'),\n      fee,\n      createdAt: Date.now(),\n    };\n\n    // 保存複製交易\n    if (!this.copiedTrades.has(relationId)) {\n      this.copiedTrades.set(relationId, []);\n    }\n    this.copiedTrades.get(relationId)!.push(copiedTrade);\n\n    // 更新統計\n    this.updateCopyStats(relationId, copiedTrade);\n\n    // 通知監聽器\n    this.notifyCopyListeners(copiedTrade);\n\n    return { copiedTradeId, copiedShares };\n  }\n\n  /**\n   * 計算縮放因子\n   */\n  private calculateScaleFactor(\n    traderAmount: Decimal,\n    followerBalance: Decimal,\n    followerAllocation: Decimal,\n    followerSettings: any\n  ): Decimal {\n    // 基於分配百分比計算可用金額\n    const availableAmount = followerBalance.times(followerAllocation).dividedBy(100);\n\n    // 基於最大交易規模限制\n    const maxAmount = followerSettings.maxTradeSize || availableAmount;\n\n    // 計算縮放因子\n    let scaleFactor = availableAmount.dividedBy(traderAmount);\n\n    // 應用限制\n    if (scaleFactor.greaterThan(this.maxScaleFactor)) {\n      scaleFactor = this.maxScaleFactor;\n    }\n    if (scaleFactor.lessThan(this.minScaleFactor)) {\n      scaleFactor = this.minScaleFactor;\n    }\n\n    // 確保不超過最大交易規模\n    if (traderAmount.times(scaleFactor).greaterThan(maxAmount)) {\n      scaleFactor = maxAmount.dividedBy(traderAmount);\n    }\n\n    return scaleFactor;\n  }\n\n  /**\n   * 執行複製交易\n   */\n  executeCopiedTrade(copiedTradeId: string, executedPrice: Decimal): boolean {\n    let copiedTrade: CopiedTrade | null = null;\n    let relationId: string | null = null;\n\n    for (const [rid, trades] of this.copiedTrades) {\n      const found = trades.find((t) => t.id === copiedTradeId);\n      if (found) {\n        copiedTrade = found;\n        relationId = rid;\n        break;\n      }\n    }\n\n    if (!copiedTrade || !relationId) return false;\n\n    copiedTrade.copiedPrice = executedPrice;\n    copiedTrade.status = 'executed';\n    copiedTrade.executedAt = Date.now();\n\n    // 計算損益\n    const priceDiff = executedPrice.minus(copiedTrade.originalPrice);\n    const pnL = copiedTrade.copiedShares.times(priceDiff).minus(copiedTrade.fee);\n    copiedTrade.pnL = pnL;\n\n    this.notifyCopyListeners(copiedTrade);\n\n    return true;\n  }\n\n  /**\n   * 取消複製交易\n   */\n  cancelCopiedTrade(copiedTradeId: string): boolean {\n    for (const trades of this.copiedTrades.values()) {\n      const trade = trades.find((t) => t.id === copiedTradeId);\n      if (trade) {\n        trade.status = 'cancelled';\n        this.notifyCopyListeners(trade);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * 更新複製統計\n   */\n  private updateCopyStats(relationId: string, copiedTrade: CopiedTrade): void {\n    if (!this.copyStats.has(relationId)) {\n      this.copyStats.set(relationId, {\n        relationId,\n        totalCopied: 0,\n        successful: 0,\n        failed: 0,\n        totalPnL: new Decimal('0'),\n        totalFee: new Decimal('0'),\n        averageScaleFactor: new Decimal('0'),\n        lastCopyTime: Date.now(),\n      });\n    }\n\n    const stats = this.copyStats.get(relationId)!;\n    stats.totalCopied++;\n    stats.totalFee = stats.totalFee.plus(copiedTrade.fee);\n    stats.lastCopyTime = Date.now();\n\n    if (copiedTrade.status === 'executed') {\n      stats.successful++;\n      stats.totalPnL = stats.totalPnL.plus(copiedTrade.pnL);\n    } else if (copiedTrade.status === 'failed') {\n      stats.failed++;\n    }\n\n    // 計算平均縮放因子\n    const allTrades = this.copiedTrades.get(relationId) || [];\n    const avgScaleFactor = allTrades.reduce((sum, t) => sum.plus(t.scaleFactor), new Decimal('0')).dividedBy(allTrades.length);\n    stats.averageScaleFactor = avgScaleFactor;\n  }\n\n  /**\n   * 獲取複製交易\n   */\n  getCopiedTrade(copiedTradeId: string): CopiedTrade | null {\n    for (const trades of this.copiedTrades.values()) {\n      const trade = trades.find((t) => t.id === copiedTradeId);\n      if (trade) return trade;\n    }\n    return null;\n  }\n\n  /**\n   * 獲取跟隨關係的複製交易\n   */\n  getRelationCopiedTrades(relationId: string, limit?: number): CopiedTrade[] {\n    const trades = this.copiedTrades.get(relationId) || [];\n    if (!limit) return trades;\n    return trades.slice(-limit);\n  }\n\n  /**\n   * 獲取複製統計\n   */\n  getCopyStats(relationId: string): CopyStats | null {\n    return this.copyStats.get(relationId) || null;\n  }\n\n  /**\n   * 獲取跟隨者的複製交易\n   */\n  getFollowerCopiedTrades(followerId: string): CopiedTrade[] {\n    return Array.from(this.copiedTrades.values())\n      .flat()\n      .filter((t) => t.followerId === followerId);\n  }\n\n  /**\n   * 設置複製費率\n   */\n  setCopyFeeRate(rate: Decimal): void {\n    if (rate.greaterThanOrEqualTo(0) && rate.lessThanOrEqualTo(0.1)) {\n      this.copyFeeRate = rate;\n    }\n  }\n\n  /**\n   * 設置最大複製延遲\n   */\n  setMaxCopyDelay(delay: number): void {\n    if (delay > 0 && delay <= 10000) {\n      this.maxCopyDelay = delay;\n    }\n  }\n\n  /**\n   * 註冊複製監聽器\n   */\n  onTradeCopied(listener: (trade: CopiedTrade) => void): void {\n    this.copyListeners.push(listener);\n  }\n\n  /**\n   * 移除複製監聽器\n   */\n  offTradeCopied(listener: (trade: CopiedTrade) => void): void {\n    const index = this.copyListeners.indexOf(listener);\n    if (index !== -1) {\n      this.copyListeners.splice(index, 1);\n    }\n  }\n\n  /**\n   * 通知複製監聽器\n   */\n  private notifyCopyListeners(trade: CopiedTrade): void {\n    for (const listener of this.copyListeners) {\n      try {\n        listener(trade);\n      } catch (error) {\n        console.error('[Trade Copier] Error in copy listener:', error);\n      }\n    }\n  }\n\n  /**\n   * 獲取統計信息\n   */\n  getStats() {\n    const totalCopied = Array.from(this.copiedTrades.values()).reduce((sum, trades) => sum + trades.length, 0);\n    const successful = Array.from(this.copiedTrades.values())\n      .flat()\n      .filter((t) => t.status === 'executed').length;\n    const totalPnL = Array.from(this.copyStats.values()).reduce((sum, stats) => sum.plus(stats.totalPnL), new Decimal('0'));\n    const totalFee = Array.from(this.copyStats.values()).reduce((sum, stats) => sum.plus(stats.totalFee), new Decimal('0'));\n\n    return {\n      totalCopied,\n      successful,\n      successRate: totalCopied > 0 ? (successful / totalCopied * 100).toFixed(2) : '0',\n      totalPnL: totalPnL.toString(),\n      totalFee: totalFee.toString(),\n      relations: this.copyStats.size,\n    };\n  }\n}\n\n// 導出單例\nexport const tradeCopier = new TradeCopier();\n
