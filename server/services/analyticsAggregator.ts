/**\n * Analytics Aggregator 服務\n * \n * 數據聚合、統計計算、指標生成、報告生成\n */\n\nimport Decimal from 'decimal.js';\n\n/**\n * 市場分析數據\n */\nexport interface MarketAnalytics {\n  marketId: string;\n  marketName: string;\n  totalVolume: Decimal; // 總成交量\n  totalTrades: number; // 總交易數\n  uniqueTraders: number; // 獨立交易者數\n  averageTradeSize: Decimal; // 平均交易規模\n  yesPrice: Decimal; // Yes 價格\n  noPrice: Decimal; // No 價格\n  spread: Decimal; // 買賣差價\n  volatility: Decimal; // 波動率\n  liquidityScore: number; // 流動性評分 (0-100)\n  trendScore: number; // 趨勢評分 (0-100)\n  sentimentScore: number; // 情感評分 (-100 到 100)\n  timestamp: number;\n}\n\n/**\n * 交易分析數據\n */\nexport interface TradeAnalytics {\n  period: 'hour' | 'day' | 'week' | 'month';\n  totalTrades: number; // 總交易數\n  totalVolume: Decimal; // 總成交量\n  totalValue: Decimal; // 總成交額\n  averageTradeSize: Decimal; // 平均交易規模\n  profitableTrades: number; // 盈利交易數\n  losingTrades: number; // 虧損交易數\n  winRate: Decimal; // 勝率\n  averageProfit: Decimal; // 平均利潤\n  averageLoss: Decimal; // 平均虧損\n  profitFactor: Decimal; // 利潤因子\n  maxDrawdown: Decimal; // 最大回撤\n  sharpeRatio: Decimal; // 夏普比率\n  timestamp: number;\n}\n\n/**\n * 用戶分析數據\n */\nexport interface UserAnalytics {\n  userId: string;\n  totalTrades: number; // 總交易數\n  totalVolume: Decimal; // 總成交量\n  totalPnL: Decimal; // 總損益\n  winRate: Decimal; // 勝率\n  averageReturn: Decimal; // 平均收益率\n  maxDrawdown: Decimal; // 最大回撤\n  riskScore: number; // 風險評分 (0-100)\n  tradingStyle: string; // 交易風格 (aggressive/balanced/conservative)\n  favoriteMarkets: string[]; // 偏好市場\n  lastTradeTime: number; // 最後交易時間\n  accountValue: Decimal; // 賬戶價值\n  timestamp: number;\n}\n\n/**\n * 性能指標\n */\nexport interface PerformanceMetrics {\n  period: 'day' | 'week' | 'month' | 'year' | 'all';\n  startDate: number;\n  endDate: number;\n  totalReturn: Decimal; // 總收益率\n  annualizedReturn: Decimal; // 年化收益率\n  volatility: Decimal; // 波動率\n  sharpeRatio: Decimal; // 夏普比率\n  sortinoRatio: Decimal; // 索提諾比率\n  maxDrawdown: Decimal; // 最大回撤\n  calmarRatio: Decimal; // 卡爾瑪比率\n  winRate: Decimal; // 勝率\n  profitFactor: Decimal; // 利潤因子\n  timestamp: number;\n}\n\n/**\n * Analytics Aggregator 服務\n */\nexport class AnalyticsAggregator {\n  private marketAnalytics: Map<string, MarketAnalytics[]> = new Map();\n  private tradeAnalytics: Map<string, TradeAnalytics[]> = new Map();\n  private userAnalytics: Map<string, UserAnalytics[]> = new Map();\n  private performanceMetrics: Map<string, PerformanceMetrics[]> = new Map();\n  private analyticsListeners: ((data: any) => void)[] = [];\n  private maxHistorySize: number = 365; // 最多保留 365 條歷史記錄\n\n  /**\n   * 聚合市場分析數據\n   */\n  aggregateMarketAnalytics(\n    marketId: string,\n    marketName: string,\n    trades: any[],\n    prices: any,\n    liquidity: any\n  ): MarketAnalytics {\n    const totalVolume = trades.reduce((sum, t) => sum.plus(t.amount || new Decimal('0')), new Decimal('0'));\n    const totalTrades = trades.length;\n    const uniqueTraders = new Set(trades.map((t) => t.userId)).size;\n    const averageTradeSize = totalTrades > 0 ? totalVolume.dividedBy(totalTrades) : new Decimal('0');\n\n    // 計算波動率\n    const volatility = this.calculateVolatility(trades);\n\n    // 計算流動性評分\n    const liquidityScore = this.calculateLiquidityScore(liquidity, totalVolume);\n\n    // 計算趨勢評分\n    const trendScore = this.calculateTrendScore(prices);\n\n    // 計算情感評分\n    const sentimentScore = this.calculateSentimentScore(trades);\n\n    const analytics: MarketAnalytics = {\n      marketId,\n      marketName,\n      totalVolume,\n      totalTrades,\n      uniqueTraders,\n      averageTradeSize,\n      yesPrice: prices?.yesPrice || new Decimal('0.5'),\n      noPrice: prices?.noPrice || new Decimal('0.5'),\n      spread: prices?.spread || new Decimal('0'),\n      volatility,\n      liquidityScore,\n      trendScore,\n      sentimentScore,\n      timestamp: Date.now(),\n    };\n\n    // 保存歷史記錄\n    if (!this.marketAnalytics.has(marketId)) {\n      this.marketAnalytics.set(marketId, []);\n    }\n    const history = this.marketAnalytics.get(marketId)!;\n    history.push(analytics);\n    if (history.length > this.maxHistorySize) {\n      history.shift();\n    }\n\n    this.notifyListeners(analytics);\n    return analytics;\n  }\n\n  /**\n   * 聚合交易分析數據\n   */\n  aggregateTradeAnalytics(period: 'hour' | 'day' | 'week' | 'month', trades: any[]): TradeAnalytics {\n    const totalTrades = trades.length;\n    const totalVolume = trades.reduce((sum, t) => sum.plus(t.shares || new Decimal('0')), new Decimal('0'));\n    const totalValue = trades.reduce((sum, t) => sum.plus(t.amount || new Decimal('0')), new Decimal('0'));\n    const averageTradeSize = totalTrades > 0 ? totalValue.dividedBy(totalTrades) : new Decimal('0');\n\n    // 計算盈虧交易\n    const profitableTrades = trades.filter((t) => (t.pnL || new Decimal('0')).greaterThan(0)).length;\n    const losingTrades = trades.filter((t) => (t.pnL || new Decimal('0')).lessThan(0)).length;\n    const winRate = totalTrades > 0 ? new Decimal(profitableTrades).dividedBy(totalTrades) : new Decimal('0');\n\n    // 計算平均利潤和虧損\n    const profitTrades = trades.filter((t) => (t.pnL || new Decimal('0')).greaterThan(0));\n    const lossTrades = trades.filter((t) => (t.pnL || new Decimal('0')).lessThan(0));\n    const averageProfit =\n      profitTrades.length > 0\n        ? profitTrades.reduce((sum, t) => sum.plus(t.pnL || new Decimal('0')), new Decimal('0')).dividedBy(profitTrades.length)\n        : new Decimal('0');\n    const averageLoss =\n      lossTrades.length > 0\n        ? lossTrades.reduce((sum, t) => sum.plus(t.pnL || new Decimal('0')), new Decimal('0')).dividedBy(lossTrades.length)\n        : new Decimal('0');\n\n    // 計算利潤因子\n    const totalProfit = profitTrades.reduce((sum, t) => sum.plus(t.pnL || new Decimal('0')), new Decimal('0'));\n    const totalLoss = lossTrades.reduce((sum, t) => sum.plus((t.pnL || new Decimal('0')).abs()), new Decimal('0'));\n    const profitFactor = totalLoss.equals(0) ? new Decimal('0') : totalProfit.dividedBy(totalLoss);\n\n    // 計算最大回撤\n    const maxDrawdown = this.calculateMaxDrawdown(trades);\n\n    // 計算夏普比率\n    const sharpeRatio = this.calculateSharpeRatio(trades);\n\n    const analytics: TradeAnalytics = {\n      period,\n      totalTrades,\n      totalVolume,\n      totalValue,\n      averageTradeSize,\n      profitableTrades,\n      losingTrades,\n      winRate,\n      averageProfit,\n      averageLoss,\n      profitFactor,\n      maxDrawdown,\n      sharpeRatio,\n      timestamp: Date.now(),\n    };\n\n    // 保存歷史記錄\n    const key = `trade-${period}`;\n    if (!this.tradeAnalytics.has(key)) {\n      this.tradeAnalytics.set(key, []);\n    }\n    const history = this.tradeAnalytics.get(key)!;\n    history.push(analytics);\n    if (history.length > this.maxHistorySize) {\n      history.shift();\n    }\n\n    this.notifyListeners(analytics);\n    return analytics;\n  }\n\n  /**\n   * 聚合用戶分析數據\n   */\n  aggregateUserAnalytics(userId: string, trades: any[], accountValue: Decimal): UserAnalytics {\n    const totalTrades = trades.length;\n    const totalVolume = trades.reduce((sum, t) => sum.plus(t.shares || new Decimal('0')), new Decimal('0'));\n    const totalPnL = trades.reduce((sum, t) => sum.plus(t.pnL || new Decimal('0')), new Decimal('0'));\n\n    // 計算勝率\n    const profitableTrades = trades.filter((t) => (t.pnL || new Decimal('0')).greaterThan(0)).length;\n    const winRate = totalTrades > 0 ? new Decimal(profitableTrades).dividedBy(totalTrades) : new Decimal('0');\n\n    // 計算平均收益率\n    const averageReturn =\n      totalTrades > 0\n        ? trades\n            .reduce((sum, t) => sum.plus((t.pnL || new Decimal('0')).dividedBy(t.amount || new Decimal('1'))), new Decimal('0'))\n            .dividedBy(totalTrades)\n        : new Decimal('0');\n\n    // 計算最大回撤\n    const maxDrawdown = this.calculateMaxDrawdown(trades);\n\n    // 計算風險評分\n    const riskScore = this.calculateRiskScore(maxDrawdown, winRate);\n\n    // 確定交易風格\n    const tradingStyle = this.determineTradingStyle(trades, winRate);\n\n    // 獲取偏好市場\n    const favoriteMarkets = this.getFavoriteMarkets(trades, 5);\n\n    // 獲取最後交易時間\n    const lastTradeTime = trades.length > 0 ? Math.max(...trades.map((t) => t.timestamp || 0)) : 0;\n\n    const analytics: UserAnalytics = {\n      userId,\n      totalTrades,\n      totalVolume,\n      totalPnL,\n      winRate,\n      averageReturn,\n      maxDrawdown,\n      riskScore,\n      tradingStyle,\n      favoriteMarkets,\n      lastTradeTime,\n      accountValue,\n      timestamp: Date.now(),\n    };\n\n    // 保存歷史記錄\n    if (!this.userAnalytics.has(userId)) {\n      this.userAnalytics.set(userId, []);\n    }\n    const history = this.userAnalytics.get(userId)!;\n    history.push(analytics);\n    if (history.length > this.maxHistorySize) {\n      history.shift();\n    }\n\n    this.notifyListeners(analytics);\n    return analytics;\n  }\n\n  /**\n   * 計算波動率\n   */\n  private calculateVolatility(trades: any[]): Decimal {\n    if (trades.length < 2) return new Decimal('0');\n\n    const prices = trades.map((t) => t.price || new Decimal('0.5'));\n    const mean = prices.reduce((sum, p) => sum.plus(p), new Decimal('0')).dividedBy(prices.length);\n    const variance = prices\n      .reduce((sum, p) => sum.plus(p.minus(mean).pow(2)), new Decimal('0'))\n      .dividedBy(prices.length);\n    return variance.sqrt();\n  }\n\n  /**\n   * 計算流動性評分\n   */\n  private calculateLiquidityScore(liquidity: any, volume: Decimal): number {\n    if (!liquidity || volume.equals(0)) return 0;\n\n    const spread = liquidity.spread || new Decimal('0.1');\n    const spreadScore = Math.max(0, 100 - Number(spread) * 100);\n\n    const depth = liquidity.depth || new Decimal('0');\n    const depthScore = Math.min(100, Number(depth) / 1000 * 100);\n\n    return Math.round((spreadScore + depthScore) / 2);\n  }\n\n  /**\n   * 計算趨勢評分\n   */\n  private calculateTrendScore(prices: any): number {\n    if (!prices) return 50;\n\n    const yesPrice = Number(prices.yesPrice || 0.5);\n    const noPrice = Number(prices.noPrice || 0.5);\n\n    if (yesPrice > noPrice) {\n      return Math.min(100, Math.round((yesPrice - noPrice) / noPrice * 100 + 50));\n    } else {\n      return Math.max(0, Math.round(50 - (noPrice - yesPrice) / yesPrice * 100));\n    }\n  }\n\n  /**\n   * 計算情感評分\n   */\n  private calculateSentimentScore(trades: any[]): number {\n    if (trades.length === 0) return 0;\n\n    const yesTrades = trades.filter((t) => t.type?.includes('yes')).length;\n    const noTrades = trades.filter((t) => t.type?.includes('no')).length;\n    const total = yesTrades + noTrades;\n\n    if (total === 0) return 0;\n\n    return Math.round((yesTrades - noTrades) / total * 100);\n  }\n\n  /**\n   * 計算最大回撤\n   */\n  private calculateMaxDrawdown(trades: any[]): Decimal {\n    if (trades.length === 0) return new Decimal('0');\n\n    let peak = new Decimal('0');\n    let maxDrawdown = new Decimal('0');\n    let cumulative = new Decimal('0');\n\n    for (const trade of trades) {\n      cumulative = cumulative.plus(trade.pnL || new Decimal('0'));\n      if (cumulative.greaterThan(peak)) {\n        peak = cumulative;\n      }\n      const drawdown = peak.minus(cumulative);\n      if (drawdown.greaterThan(maxDrawdown)) {\n        maxDrawdown = drawdown;\n      }\n    }\n\n    return maxDrawdown;\n  }\n\n  /**\n   * 計算夏普比率\n   */\n  private calculateSharpeRatio(trades: any[]): Decimal {\n    if (trades.length < 2) return new Decimal('0');\n\n    const returns = trades.map((t) => t.pnL || new Decimal('0'));\n    const mean = returns.reduce((sum, r) => sum.plus(r), new Decimal('0')).dividedBy(returns.length);\n    const variance = returns\n      .reduce((sum, r) => sum.plus(r.minus(mean).pow(2)), new Decimal('0'))\n      .dividedBy(returns.length);\n    const stdDev = variance.sqrt();\n\n    return stdDev.equals(0) ? new Decimal('0') : mean.dividedBy(stdDev);\n  }\n\n  /**\n   * 計算風險評分\n   */\n  private calculateRiskScore(maxDrawdown: Decimal, winRate: Decimal): number {\n    const drawdownScore = Math.min(100, Number(maxDrawdown) * 100);\n    const winRateScore = Math.max(0, 100 - Number(winRate) * 100);\n    return Math.round((drawdownScore + winRateScore) / 2);\n  }\n\n  /**\n   * 確定交易風格\n   */\n  private determineTradingStyle(trades: any[], winRate: Decimal): string {\n    const avgTradeSize = trades.reduce((sum, t) => sum.plus(t.amount || new Decimal('0')), new Decimal('0')).dividedBy(trades.length || 1);\n    const frequency = trades.length;\n\n    if (Number(winRate) > 0.6 && frequency > 50) {\n      return 'aggressive';\n    } else if (Number(winRate) > 0.5 && frequency > 20) {\n      return 'balanced';\n    } else {\n      return 'conservative';\n    }\n  }\n\n  /**\n   * 獲取偏好市場\n   */\n  private getFavoriteMarkets(trades: any[], limit: number): string[] {\n    const marketCounts = new Map<string, number>();\n    for (const trade of trades) {\n      const marketId = trade.marketId || 'unknown';\n      marketCounts.set(marketId, (marketCounts.get(marketId) || 0) + 1);\n    }\n\n    return Array.from(marketCounts.entries())\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, limit)\n      .map((entry) => entry[0]);\n  }\n\n  /**\n   * 獲取市場分析\n   */\n  getMarketAnalytics(marketId: string, limit?: number): MarketAnalytics[] {\n    const history = this.marketAnalytics.get(marketId) || [];\n    if (!limit) return history;\n    return history.slice(-limit);\n  }\n\n  /**\n   * 獲取交易分析\n   */\n  getTradeAnalytics(period: 'hour' | 'day' | 'week' | 'month', limit?: number): TradeAnalytics[] {\n    const key = `trade-${period}`;\n    const history = this.tradeAnalytics.get(key) || [];\n    if (!limit) return history;\n    return history.slice(-limit);\n  }\n\n  /**\n   * 獲取用戶分析\n   */\n  getUserAnalytics(userId: string, limit?: number): UserAnalytics[] {\n    const history = this.userAnalytics.get(userId) || [];\n    if (!limit) return history;\n    return history.slice(-limit);\n  }\n\n  /**\n   * 註冊分析監聽器\n   */\n  onAnalyticsUpdate(listener: (data: any) => void): void {\n    this.analyticsListeners.push(listener);\n  }\n\n  /**\n   * 移除分析監聽器\n   */\n  offAnalyticsUpdate(listener: (data: any) => void): void {\n    const index = this.analyticsListeners.indexOf(listener);\n    if (index !== -1) {\n      this.analyticsListeners.splice(index, 1);\n    }\n  }\n\n  /**\n   * 通知監聽器\n   */\n  private notifyListeners(data: any): void {\n    for (const listener of this.analyticsListeners) {\n      try {\n        listener(data);\n      } catch (error) {\n        console.error('[Analytics Aggregator] Error in listener:', error);\n      }\n    }\n  }\n\n  /**\n   * 獲取統計信息\n   */\n  getStats() {\n    return {\n      markets: this.marketAnalytics.size,\n      tradeAnalytics: this.tradeAnalytics.size,\n      users: this.userAnalytics.size,\n      listeners: this.analyticsListeners.length,\n    };\n  }\n}\n\n// 導出單例\nexport const analyticsAggregator = new AnalyticsAggregator();\n
