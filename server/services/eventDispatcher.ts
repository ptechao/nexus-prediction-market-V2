/**\n * Event Dispatcher 服務\n * \n * 事件發送、事件路由、事件通知、事件聚合\n */\n\nimport { MarketEvent, MarketEventType } from './marketEventMonitor';\n\n/**\n * 事件訂閱者\n */\ninterface EventSubscriber {\n  id: string;\n  marketId?: string; // undefined 表示訂閱所有市場\n  eventTypes: MarketEventType[];\n  handler: (event: MarketEvent) => Promise<void>;\n  active: boolean;\n}\n\n/**\n * 事件隊列項\n */\ninterface QueuedEvent {\n  event: MarketEvent;\n  subscribers: string[];\n  retries: number;\n  maxRetries: number;\n}\n\n/**\n * 事件統計\n */\ninterface EventStats {\n  dispatched: number;\n  failed: number;\n  retried: number;\n  subscribers: number;\n}\n\n/**\n * Event Dispatcher 服務\n */\nclass EventDispatcher {\n  private subscribers: Map<string, EventSubscriber> = new Map();\n  private eventQueue: QueuedEvent[] = [];\n  private stats: EventStats = {\n    dispatched: 0,\n    failed: 0,\n    retried: 0,\n    subscribers: 0,\n  };\n  private processingQueue: boolean = false;\n  private queueInterval?: NodeJS.Timeout;\n  private maxQueueSize: number = 10000;\n  private processingBatchSize: number = 100;\n\n  /**\n   * 啟動事件分發\n   */\n  start(): void {\n    if (this.queueInterval) return;\n\n    console.log('[Event Dispatcher] Starting event dispatcher');\n    this.queueInterval = setInterval(() => this.processQueue(), 1000);\n  }\n\n  /**\n   * 停止事件分發\n   */\n  stop(): void {\n    if (this.queueInterval) {\n      clearInterval(this.queueInterval);\n      this.queueInterval = undefined;\n      console.log('[Event Dispatcher] Stopped event dispatcher');\n    }\n  }\n\n  /**\n   * 訂閱事件\n   */\n  subscribe(\n    marketId: string | undefined,\n    eventTypes: MarketEventType[],\n    handler: (event: MarketEvent) => Promise<void>\n  ): string {\n    const subscriberId = `subscriber-${Date.now()}-${Math.random()}`;\n\n    const subscriber: EventSubscriber = {\n      id: subscriberId,\n      marketId,\n      eventTypes,\n      handler,\n      active: true,\n    };\n\n    this.subscribers.set(subscriberId, subscriber);\n    this.stats.subscribers = this.subscribers.size;\n\n    console.log(\n      `[Event Dispatcher] Subscriber ${subscriberId} registered for market ${marketId || 'all'} events: ${eventTypes.join(\n        ', '\n      )}`\n    );\n\n    return subscriberId;\n  }\n\n  /**\n   * 取消訂閱\n   */\n  unsubscribe(subscriberId: string): boolean {\n    const removed = this.subscribers.delete(subscriberId);\n    if (removed) {\n      this.stats.subscribers = this.subscribers.size;\n      console.log(`[Event Dispatcher] Subscriber ${subscriberId} unregistered`);\n    }\n    return removed;\n  }\n\n  /**\n   * 分發事件\n   */\n  async dispatch(event: MarketEvent): Promise<void> {\n    // 查找匹配的訂閱者\n    const matchingSubscribers: string[] = [];\n\n    for (const [subscriberId, subscriber] of this.subscribers) {\n      if (!subscriber.active) continue;\n\n      // 檢查市場 ID 是否匹配\n      if (subscriber.marketId && subscriber.marketId !== event.marketId) continue;\n\n      // 檢查事件類型是否匹配\n      if (!subscriber.eventTypes.includes(event.type)) continue;\n\n      matchingSubscribers.push(subscriberId);\n    }\n\n    if (matchingSubscribers.length === 0) {\n      console.log(`[Event Dispatcher] No subscribers for event ${event.type} on market ${event.marketId}`);\n      return;\n    }\n\n    // 添加到隊列\n    const queuedEvent: QueuedEvent = {\n      event,\n      subscribers: matchingSubscribers,\n      retries: 0,\n      maxRetries: 3,\n    };\n\n    if (this.eventQueue.length < this.maxQueueSize) {\n      this.eventQueue.push(queuedEvent);\n    } else {\n      console.error('[Event Dispatcher] Event queue is full, dropping event');\n      this.stats.failed++;\n    }\n  }\n\n  /**\n   * 處理事件隊列\n   */\n  private async processQueue(): Promise<void> {\n    if (this.processingQueue || this.eventQueue.length === 0) return;\n\n    this.processingQueue = true;\n\n    try {\n      const batch = this.eventQueue.splice(0, this.processingBatchSize);\n\n      for (const queuedEvent of batch) {\n        await this.processQueuedEvent(queuedEvent);\n      }\n    } catch (error) {\n      console.error('[Event Dispatcher] Error processing queue:', error);\n    } finally {\n      this.processingQueue = false;\n    }\n  }\n\n  /**\n   * 處理隊列中的事件\n   */\n  private async processQueuedEvent(queuedEvent: QueuedEvent): Promise<void> {\n    const failedSubscribers: string[] = [];\n\n    for (const subscriberId of queuedEvent.subscribers) {\n      const subscriber = this.subscribers.get(subscriberId);\n      if (!subscriber || !subscriber.active) continue;\n\n      try {\n        await subscriber.handler(queuedEvent.event);\n        this.stats.dispatched++;\n      } catch (error) {\n        console.error(`[Event Dispatcher] Error dispatching to subscriber ${subscriberId}:`, error);\n        failedSubscribers.push(subscriberId);\n      }\n    }\n\n    // 重試失敗的訂閱者\n    if (failedSubscribers.length > 0 && queuedEvent.retries < queuedEvent.maxRetries) {\n      queuedEvent.retries++;\n      queuedEvent.subscribers = failedSubscribers;\n      this.eventQueue.push(queuedEvent);\n      this.stats.retried++;\n    } else if (failedSubscribers.length > 0) {\n      console.error(\n        `[Event Dispatcher] Event failed after ${queuedEvent.maxRetries} retries for subscribers: ${failedSubscribers.join(\n          ', '\n        )}`\n      );\n      this.stats.failed++;\n    }\n  }\n\n  /**\n   * 獲取訂閱者列表\n   */\n  getSubscribers(marketId?: string): EventSubscriber[] {\n    const result: EventSubscriber[] = [];\n\n    for (const subscriber of this.subscribers.values()) {\n      if (marketId && subscriber.marketId && subscriber.marketId !== marketId) continue;\n      result.push(subscriber);\n    }\n\n    return result;\n  }\n\n  /**\n   * 獲取隊列狀態\n   */\n  getQueueStatus() {\n    return {\n      queueSize: this.eventQueue.length,\n      maxQueueSize: this.maxQueueSize,\n      processingQueue: this.processingQueue,\n    };\n  }\n\n  /**\n   * 獲取統計信息\n   */\n  getStats(): EventStats {\n    return { ...this.stats };\n  }\n\n  /**\n   * 重置統計信息\n   */\n  resetStats(): void {\n    this.stats = {\n      dispatched: 0,\n      failed: 0,\n      retried: 0,\n      subscribers: this.subscribers.size,\n    };\n  }\n\n  /**\n   * 啟用/禁用訂閱者\n   */\n  setSubscriberActive(subscriberId: string, active: boolean): boolean {\n    const subscriber = this.subscribers.get(subscriberId);\n    if (!subscriber) return false;\n\n    subscriber.active = active;\n    return true;\n  }\n\n  /**\n   * 清理隊列\n   */\n  clearQueue(): void {\n    this.eventQueue = [];\n    console.log('[Event Dispatcher] Event queue cleared');\n  }\n\n  /**\n   * 清理所有訂閱者\n   */\n  clearSubscribers(): void {\n    this.subscribers.clear();\n    this.stats.subscribers = 0;\n    console.log('[Event Dispatcher] All subscribers cleared');\n  }\n}\n\n// 導出單例\nconst eventDispatcher = new EventDispatcher();\n\nexport default eventDispatcher;\nexport type { EventSubscriber, QueuedEvent, EventStats };\n
