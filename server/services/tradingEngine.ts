/**\n * Trading Engine 服務\n * \n * 交易邏輯、訂單驗證、交易執行、風險管理\n */\n\nimport Decimal from 'decimal.js';\n\n/**\n * 訂單類型\n */\nexport enum OrderType {\n  BUY_YES = 'buy_yes',\n  BUY_NO = 'buy_no',\n  SELL_YES = 'sell_yes',\n  SELL_NO = 'sell_no',\n}\n\n/**\n * 訂單狀態\n */\nexport enum OrderStatus {\n  PENDING = 'pending',\n  FILLED = 'filled',\n  PARTIALLY_FILLED = 'partially_filled',\n  CANCELLED = 'cancelled',\n  REJECTED = 'rejected',\n}\n\n/**\n * 訂單\n */\nexport interface Order {\n  id: string;\n  marketId: string;\n  userId: string;\n  type: OrderType;\n  amount: Decimal; // 投入金額\n  shares: Decimal; // 購買份額\n  price: Decimal; // 執行價格\n  status: OrderStatus;\n  filledAmount: Decimal;\n  filledShares: Decimal;\n  createdAt: number;\n  updatedAt: number;\n  expiresAt?: number;\n}\n\n/**\n * 交易\n */\nexport interface Trade {\n  id: string;\n  orderId: string;\n  marketId: string;\n  userId: string;\n  counterpartyId?: string; // 對手方用戶 ID\n  type: OrderType;\n  shares: Decimal;\n  price: Decimal;\n  amount: Decimal;\n  fee: Decimal;\n  netAmount: Decimal;\n  timestamp: number;\n}\n\n/**\n * 市場流動性\n */\nexport interface MarketLiquidity {\n  marketId: string;\n  yesBid: Decimal; // Yes 買入價\n  yesAsk: Decimal; // Yes 賣出價\n  noBid: Decimal; // No 買入價\n  noAsk: Decimal; // No 賣出價\n  yesVolume: Decimal; // Yes 成交量\n  noVolume: Decimal; // No 成交量\n  spread: Decimal; // 買賣差價\n  lastUpdate: number;\n}\n\n/**\n * 風險指標\n */\nexport interface RiskMetrics {\n  userExposure: Decimal; // 用戶敞口\n  marketExposure: Decimal; // 市場敞口\n  concentrationRatio: Decimal; // 集中度比率\n  volatility: Decimal; // 波動率\n  riskScore: number; // 0-100\n}\n\n/**\n * Trading Engine 服務\n */\nexport class TradingEngine {\n  private orders: Map<string, Order> = new Map();\n  private trades: Map<string, Trade[]> = new Map();\n  private marketLiquidity: Map<string, MarketLiquidity> = new Map();\n  private userBalances: Map<string, Decimal> = new Map();\n  private feeRate: Decimal = new Decimal('0.01'); // 1% 手續費\n  private minOrderAmount: Decimal = new Decimal('1'); // 最小訂單金額\n  private maxOrderAmount: Decimal = new Decimal('1000000'); // 最大訂單金額\n  private riskLimits = {\n    maxUserExposure: new Decimal('100000'), // 最大用戶敞口\n    maxMarketExposure: new Decimal('1000000'), // 最大市場敞口\n    maxConcentration: new Decimal('0.3'), // 最大集中度 30%\n  };\n\n  /**\n   * 創建訂單\n   */\n  createOrder(\n    marketId: string,\n    userId: string,\n    type: OrderType,\n    amount: Decimal,\n    expiresAt?: number\n  ): { orderId: string; error?: string } {\n    // 驗證訂單金額\n    if (amount.lessThan(this.minOrderAmount)) {\n      return { orderId: '', error: `Order amount must be at least ${this.minOrderAmount}` };\n    }\n    if (amount.greaterThan(this.maxOrderAmount)) {\n      return { orderId: '', error: `Order amount must not exceed ${this.maxOrderAmount}` };\n    }\n\n    // 驗證用戶餘額\n    const userBalance = this.userBalances.get(userId) || new Decimal('0');\n    if (userBalance.lessThan(amount)) {\n      return { orderId: '', error: 'Insufficient balance' };\n    }\n\n    // 獲取市場流動性\n    const liquidity = this.marketLiquidity.get(marketId);\n    if (!liquidity) {\n      return { orderId: '', error: 'Market not found' };\n    }\n\n    // 計算執行價格和份額\n    const { price, shares, error: priceError } = this.calculateExecutionPrice(type, amount, liquidity);\n    if (priceError) {\n      return { orderId: '', error: priceError };\n    }\n\n    // 創建訂單\n    const orderId = `order-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    const order: Order = {\n      id: orderId,\n      marketId,\n      userId,\n      type,\n      amount,\n      shares,\n      price,\n      status: OrderStatus.PENDING,\n      filledAmount: new Decimal('0'),\n      filledShares: new Decimal('0'),\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n      expiresAt,\n    };\n\n    this.orders.set(orderId, order);\n\n    // 執行訂單\n    this.executeOrder(orderId);\n\n    return { orderId };\n  }\n\n  /**\n   * 計算執行價格\n   */\n  private calculateExecutionPrice(\n    type: OrderType,\n    amount: Decimal,\n    liquidity: MarketLiquidity\n  ): { price: Decimal; shares: Decimal; error?: string } {\n    let price: Decimal;\n    let shares: Decimal;\n\n    switch (type) {\n      case OrderType.BUY_YES:\n        price = liquidity.yesAsk;\n        shares = amount.dividedBy(price);\n        break;\n      case OrderType.BUY_NO:\n        price = liquidity.noAsk;\n        shares = amount.dividedBy(price);\n        break;\n      case OrderType.SELL_YES:\n        price = liquidity.yesBid;\n        shares = amount.dividedBy(price);\n        break;\n      case OrderType.SELL_NO:\n        price = liquidity.noBid;\n        shares = amount.dividedBy(price);\n        break;\n    }\n\n    // 檢查流動性\n    const requiredVolume = type.includes('yes') ? liquidity.yesVolume : liquidity.noVolume;\n    if (shares.greaterThan(requiredVolume.times(0.1))) {\n      return { price: new Decimal('0'), shares: new Decimal('0'), error: 'Insufficient liquidity' };\n    }\n\n    return { price, shares };\n  }\n\n  /**\n   * 執行訂單\n   */\n  private executeOrder(orderId: string): void {\n    const order = this.orders.get(orderId);\n    if (!order) return;\n\n    // 檢查風險\n    const riskMetrics = this.calculateRiskMetrics(order.userId, order.marketId, order.amount);\n    if (riskMetrics.riskScore > 80) {\n      order.status = OrderStatus.REJECTED;\n      order.updatedAt = Date.now();\n      return;\n    }\n\n    // 創建交易\n    const trade: Trade = {\n      id: `trade-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      orderId,\n      marketId: order.marketId,\n      userId: order.userId,\n      type: order.type,\n      shares: order.shares,\n      price: order.price,\n      amount: order.amount,\n      fee: order.amount.times(this.feeRate),\n      netAmount: order.amount.minus(order.amount.times(this.feeRate)),\n      timestamp: Date.now(),\n    };\n\n    // 保存交易\n    if (!this.trades.has(order.marketId)) {\n      this.trades.set(order.marketId, []);\n    }\n    this.trades.get(order.marketId)!.push(trade);\n\n    // 更新訂單狀態\n    order.filledAmount = order.amount;\n    order.filledShares = order.shares;\n    order.status = OrderStatus.FILLED;\n    order.updatedAt = Date.now();\n\n    // 更新用戶餘額\n    const userBalance = this.userBalances.get(order.userId) || new Decimal('0');\n    this.userBalances.set(order.userId, userBalance.minus(order.amount.plus(trade.fee)));\n\n    // 更新市場流動性\n    this.updateMarketLiquidity(order.marketId, order.type, order.shares);\n  }\n\n  /**\n   * 更新市場流動性\n   */\n  private updateMarketLiquidity(marketId: string, orderType: OrderType, shares: Decimal): void {\n    const liquidity = this.marketLiquidity.get(marketId);\n    if (!liquidity) return;\n\n    // 根據訂單類型更新流動性\n    switch (orderType) {\n      case OrderType.BUY_YES:\n        liquidity.yesVolume = liquidity.yesVolume.minus(shares);\n        break;\n      case OrderType.BUY_NO:\n        liquidity.noVolume = liquidity.noVolume.minus(shares);\n        break;\n      case OrderType.SELL_YES:\n        liquidity.yesVolume = liquidity.yesVolume.plus(shares);\n        break;\n      case OrderType.SELL_NO:\n        liquidity.noVolume = liquidity.noVolume.plus(shares);\n        break;\n    }\n\n    liquidity.lastUpdate = Date.now();\n  }\n\n  /**\n   * 計算風險指標\n   */\n  private calculateRiskMetrics(userId: string, marketId: string, orderAmount: Decimal): RiskMetrics {\n    // 計算用戶敞口\n    const userTrades = Array.from(this.trades.values()).flat().filter((t) => t.userId === userId);\n    const userExposure = userTrades.reduce((sum, t) => sum.plus(t.amount), new Decimal('0')).plus(orderAmount);\n\n    // 計算市場敞口\n    const marketTrades = this.trades.get(marketId) || [];\n    const marketExposure = marketTrades.reduce((sum, t) => sum.plus(t.amount), new Decimal('0')).plus(orderAmount);\n\n    // 計算集中度比率\n    const concentrationRatio = marketTrades.length > 0 ? orderAmount.dividedBy(marketExposure) : new Decimal('0');\n\n    // 計算波動率（簡化版）\n    const volatility = new Decimal('0.1'); // TODO: 從價格歷史計算\n\n    // 計算風險分數\n    let riskScore = 0;\n    if (userExposure.greaterThan(this.riskLimits.maxUserExposure)) riskScore += 30;\n    if (marketExposure.greaterThan(this.riskLimits.maxMarketExposure)) riskScore += 30;\n    if (concentrationRatio.greaterThan(this.riskLimits.maxConcentration)) riskScore += 20;\n    if (volatility.greaterThan(new Decimal('0.5'))) riskScore += 20;\n\n    return {\n      userExposure,\n      marketExposure,\n      concentrationRatio,\n      volatility,\n      riskScore,\n    };\n  }\n\n  /**\n   * 取消訂單\n   */\n  cancelOrder(orderId: string): boolean {\n    const order = this.orders.get(orderId);\n    if (!order) return false;\n\n    if (order.status === OrderStatus.FILLED || order.status === OrderStatus.CANCELLED) {\n      return false;\n    }\n\n    order.status = OrderStatus.CANCELLED;\n    order.updatedAt = Date.now();\n\n    // 退款\n    const userBalance = this.userBalances.get(order.userId) || new Decimal('0');\n    this.userBalances.set(order.userId, userBalance.plus(order.amount.minus(order.filledAmount)));\n\n    return true;\n  }\n\n  /**\n   * 獲取訂單\n   */\n  getOrder(orderId: string): Order | null {\n    return this.orders.get(orderId) || null;\n  }\n\n  /**\n   * 獲取用戶訂單\n   */\n  getUserOrders(userId: string): Order[] {\n    return Array.from(this.orders.values()).filter((o) => o.userId === userId);\n  }\n\n  /**\n   * 獲取市場交易\n   */\n  getMarketTrades(marketId: string, limit?: number): Trade[] {\n    const trades = this.trades.get(marketId) || [];\n    if (!limit) return trades;\n    return trades.slice(-limit);\n  }\n\n  /**\n   * 獲取用戶交易\n   */\n  getUserTrades(userId: string): Trade[] {\n    return Array.from(this.trades.values())\n      .flat()\n      .filter((t) => t.userId === userId);\n  }\n\n  /**\n   * 獲取市場流動性\n   */\n  getMarketLiquidity(marketId: string): MarketLiquidity | null {\n    return this.marketLiquidity.get(marketId) || null;\n  }\n\n  /**\n   * 設置市場流動性\n   */\n  setMarketLiquidity(marketId: string, liquidity: MarketLiquidity): void {\n    this.marketLiquidity.set(marketId, liquidity);\n  }\n\n  /**\n   * 獲取用戶餘額\n   */\n  getUserBalance(userId: string): Decimal {\n    return this.userBalances.get(userId) || new Decimal('0');\n  }\n\n  /**\n   * 設置用戶餘額\n   */\n  setUserBalance(userId: string, balance: Decimal): void {\n    this.userBalances.set(userId, balance);\n  }\n\n  /**\n   * 獲取統計信息\n   */\n  getStats() {\n    const totalTrades = Array.from(this.trades.values()).reduce((sum, trades) => sum + trades.length, 0);\n    const totalVolume = Array.from(this.trades.values())\n      .flat()\n      .reduce((sum, t) => sum.plus(t.amount), new Decimal('0'));\n\n    return {\n      orders: this.orders.size,\n      trades: totalTrades,\n      volume: totalVolume.toString(),\n      users: this.userBalances.size,\n      markets: this.marketLiquidity.size,\n    };\n  }\n}\n\n// 導出單例\nexport const tradingEngine = new TradingEngine();\n
