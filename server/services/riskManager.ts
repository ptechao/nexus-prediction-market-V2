/**\n * Risk Manager 服務\n * \n * 風險評估、風險控制、風險限制、風險告警\n */\n\nimport Decimal from 'decimal.js';\n\n/**\n * 風險級別\n */\nexport enum RiskLevel {\n  LOW = 'low',\n  MEDIUM = 'medium',\n  HIGH = 'high',\n  CRITICAL = 'critical',\n}\n\n/**\n * 風險因子\n */\nexport interface RiskFactor {\n  name: string;\n  value: Decimal;\n  weight: Decimal; // 0-1\n  threshold: Decimal;\n  level: RiskLevel;\n}\n\n/**\n * 風險評估結果\n */\nexport interface RiskAssessment {\n  userId: string;\n  marketId: string;\n  overallRiskScore: number; // 0-100\n  riskLevel: RiskLevel;\n  factors: RiskFactor[];\n  violations: string[];\n  recommendations: string[];\n  timestamp: number;\n}\n\n/**\n * 風險限制\n */\nexport interface RiskLimits {\n  maxExposurePerMarket: Decimal;\n  maxExposurePerUser: Decimal;\n  maxConcentration: Decimal;\n  maxLeverage: Decimal;\n  maxDrawdown: Decimal;\n  minCollateral: Decimal;\n}\n\n/**\n * Risk Manager 服務\n */\nexport class RiskManager {\n  private riskLimits: RiskLimits = {\n    maxExposurePerMarket: new Decimal('1000000'),\n    maxExposurePerUser: new Decimal('100000'),\n    maxConcentration: new Decimal('0.3'), // 30%\n    maxLeverage: new Decimal('2'),\n    maxDrawdown: new Decimal('0.2'), // 20%\n    minCollateral: new Decimal('0.1'), // 10%\n  };\n  private userRiskProfiles: Map<string, RiskAssessment[]> = new Map();\n  private riskAlerts: Map<string, string[]> = new Map();\n  private riskListeners: ((assessment: RiskAssessment) => void)[] = [];\n\n  /**\n   * 評估風險\n   */\n  assessRisk(\n    userId: string,\n    marketId: string,\n    exposure: Decimal,\n    totalExposure: Decimal,\n    marketVolume: Decimal,\n    userBalance: Decimal,\n    userPnL: Decimal\n  ): RiskAssessment {\n    const factors: RiskFactor[] = [];\n    const violations: string[] = [];\n    const recommendations: string[] = [];\n\n    // 計算市場敞口因子\n    const marketExposureFactor = this.calculateMarketExposureFactor(exposure, this.riskLimits.maxExposurePerMarket);\n    factors.push({\n      name: 'Market Exposure',\n      value: exposure,\n      weight: new Decimal('0.25'),\n      threshold: this.riskLimits.maxExposurePerMarket,\n      level: marketExposureFactor.level,\n    });\n    if (marketExposureFactor.violated) {\n      violations.push('Market exposure exceeds limit');\n      recommendations.push('Reduce position size in this market');\n    }\n\n    // 計算用戶敞口因子\n    const userExposureFactor = this.calculateUserExposureFactor(totalExposure, this.riskLimits.maxExposurePerUser);\n    factors.push({\n      name: 'User Exposure',\n      value: totalExposure,\n      weight: new Decimal('0.25'),\n      threshold: this.riskLimits.maxExposurePerUser,\n      level: userExposureFactor.level,\n    });\n    if (userExposureFactor.violated) {\n      violations.push('Total exposure exceeds user limit');\n      recommendations.push('Reduce overall portfolio size');\n    }\n\n    // 計算集中度因子\n    const concentrationFactor = this.calculateConcentrationFactor(exposure, marketVolume, this.riskLimits.maxConcentration);\n    factors.push({\n      name: 'Concentration',\n      value: exposure.dividedBy(marketVolume),\n      weight: new Decimal('0.2'),\n      threshold: this.riskLimits.maxConcentration,\n      level: concentrationFactor.level,\n    });\n    if (concentrationFactor.violated) {\n      violations.push('Position concentration exceeds limit');\n      recommendations.push('Diversify across multiple markets');\n    }\n\n    // 計算槓桿因子\n    const leverageFactor = this.calculateLeverageFactor(exposure, userBalance, this.riskLimits.maxLeverage);\n    factors.push({\n      name: 'Leverage',\n      value: exposure.dividedBy(userBalance),\n      weight: new Decimal('0.15'),\n      threshold: this.riskLimits.maxLeverage,\n      level: leverageFactor.level,\n    });\n    if (leverageFactor.violated) {\n      violations.push('Leverage exceeds limit');\n      recommendations.push('Increase collateral or reduce position');\n    }\n\n    // 計算回撤因子\n    const drawdownFactor = this.calculateDrawdownFactor(userPnL, userBalance, this.riskLimits.maxDrawdown);\n    factors.push({\n      name: 'Drawdown',\n      value: userPnL.dividedBy(userBalance),\n      weight: new Decimal('0.15'),\n      threshold: this.riskLimits.maxDrawdown.negated(),\n      level: drawdownFactor.level,\n    });\n    if (drawdownFactor.violated) {\n      violations.push('Drawdown exceeds limit');\n      recommendations.push('Consider closing losing positions');\n    }\n\n    // 計算總體風險分數\n    let overallRiskScore = 0;\n    for (const factor of factors) {\n      const score = this.riskLevelToScore(factor.level);\n      overallRiskScore += score * Number(factor.weight);\n    }\n\n    // 確定風險級別\n    const riskLevel = this.scoreToRiskLevel(overallRiskScore);\n\n    const assessment: RiskAssessment = {\n      userId,\n      marketId,\n      overallRiskScore: Math.round(overallRiskScore),\n      riskLevel,\n      factors,\n      violations,\n      recommendations,\n      timestamp: Date.now(),\n    };\n\n    // 保存評估結果\n    if (!this.userRiskProfiles.has(userId)) {\n      this.userRiskProfiles.set(userId, []);\n    }\n    const profiles = this.userRiskProfiles.get(userId)!;\n    profiles.push(assessment);\n    if (profiles.length > 100) {\n      profiles.shift();\n    }\n\n    // 通知監聽器\n    this.notifyListeners(assessment);\n\n    return assessment;\n  }\n\n  /**\n   * 計算市場敞口因子\n   */\n  private calculateMarketExposureFactor(exposure: Decimal, limit: Decimal): { level: RiskLevel; violated: boolean } {\n    const ratio = exposure.dividedBy(limit);\n    if (ratio.greaterThan(1)) {\n      return { level: RiskLevel.CRITICAL, violated: true };\n    } else if (ratio.greaterThan(0.8)) {\n      return { level: RiskLevel.HIGH, violated: false };\n    } else if (ratio.greaterThan(0.5)) {\n      return { level: RiskLevel.MEDIUM, violated: false };\n    } else {\n      return { level: RiskLevel.LOW, violated: false };\n    }\n  }\n\n  /**\n   * 計算用戶敞口因子\n   */\n  private calculateUserExposureFactor(exposure: Decimal, limit: Decimal): { level: RiskLevel; violated: boolean } {\n    const ratio = exposure.dividedBy(limit);\n    if (ratio.greaterThan(1)) {\n      return { level: RiskLevel.CRITICAL, violated: true };\n    } else if (ratio.greaterThan(0.8)) {\n      return { level: RiskLevel.HIGH, violated: false };\n    } else if (ratio.greaterThan(0.5)) {\n      return { level: RiskLevel.MEDIUM, violated: false };\n    } else {\n      return { level: RiskLevel.LOW, violated: false };\n    }\n  }\n\n  /**\n   * 計算集中度因子\n   */\n  private calculateConcentrationFactor(\n    exposure: Decimal,\n    marketVolume: Decimal,\n    limit: Decimal\n  ): { level: RiskLevel; violated: boolean } {\n    if (marketVolume.equals(0)) {\n      return { level: RiskLevel.CRITICAL, violated: true };\n    }\n    const ratio = exposure.dividedBy(marketVolume);\n    if (ratio.greaterThan(limit)) {\n      return { level: RiskLevel.CRITICAL, violated: true };\n    } else if (ratio.greaterThan(limit.times(0.8))) {\n      return { level: RiskLevel.HIGH, violated: false };\n    } else if (ratio.greaterThan(limit.times(0.5))) {\n      return { level: RiskLevel.MEDIUM, violated: false };\n    } else {\n      return { level: RiskLevel.LOW, violated: false };\n    }\n  }\n\n  /**\n   * 計算槓桿因子\n   */\n  private calculateLeverageFactor(exposure: Decimal, balance: Decimal, limit: Decimal): { level: RiskLevel; violated: boolean } {\n    if (balance.equals(0)) {\n      return { level: RiskLevel.CRITICAL, violated: true };\n    }\n    const ratio = exposure.dividedBy(balance);\n    if (ratio.greaterThan(limit)) {\n      return { level: RiskLevel.CRITICAL, violated: true };\n    } else if (ratio.greaterThan(limit.times(0.8))) {\n      return { level: RiskLevel.HIGH, violated: false };\n    } else if (ratio.greaterThan(limit.times(0.5))) {\n      return { level: RiskLevel.MEDIUM, violated: false };\n    } else {\n      return { level: RiskLevel.LOW, violated: false };\n    }\n  }\n\n  /**\n   * 計算回撤因子\n   */\n  private calculateDrawdownFactor(pnL: Decimal, balance: Decimal, limit: Decimal): { level: RiskLevel; violated: boolean } {\n    if (balance.equals(0)) {\n      return { level: RiskLevel.LOW, violated: false };\n    }\n    const ratio = pnL.dividedBy(balance);\n    if (ratio.lessThan(limit)) {\n      return { level: RiskLevel.CRITICAL, violated: true };\n    } else if (ratio.lessThan(limit.times(0.8))) {\n      return { level: RiskLevel.HIGH, violated: false };\n    } else if (ratio.lessThan(limit.times(0.5))) {\n      return { level: RiskLevel.MEDIUM, violated: false };\n    } else {\n      return { level: RiskLevel.LOW, violated: false };\n    }\n  }\n\n  /**\n   * 風險級別轉分數\n   */\n  private riskLevelToScore(level: RiskLevel): number {\n    switch (level) {\n      case RiskLevel.LOW:\n        return 20;\n      case RiskLevel.MEDIUM:\n        return 50;\n      case RiskLevel.HIGH:\n        return 75;\n      case RiskLevel.CRITICAL:\n        return 100;\n    }\n  }\n\n  /**\n   * 分數轉風險級別\n   */\n  private scoreToRiskLevel(score: number): RiskLevel {\n    if (score >= 80) {\n      return RiskLevel.CRITICAL;\n    } else if (score >= 60) {\n      return RiskLevel.HIGH;\n    } else if (score >= 40) {\n      return RiskLevel.MEDIUM;\n    } else {\n      return RiskLevel.LOW;\n    }\n  }\n\n  /**\n   * 設置風險限制\n   */\n  setRiskLimits(limits: Partial<RiskLimits>): void {\n    this.riskLimits = { ...this.riskLimits, ...limits };\n  }\n\n  /**\n   * 獲取風險限制\n   */\n  getRiskLimits(): RiskLimits {\n    return { ...this.riskLimits };\n  }\n\n  /**\n   * 獲取用戶風險歷史\n   */\n  getUserRiskHistory(userId: string, limit?: number): RiskAssessment[] {\n    const history = this.userRiskProfiles.get(userId) || [];\n    if (!limit) return history;\n    return history.slice(-limit);\n  }\n\n  /**\n   * 註冊風險監聽器\n   */\n  onRiskAssessment(listener: (assessment: RiskAssessment) => void): void {\n    this.riskListeners.push(listener);\n  }\n\n  /**\n   * 移除風險監聽器\n   */\n  offRiskAssessment(listener: (assessment: RiskAssessment) => void): void {\n    const index = this.riskListeners.indexOf(listener);\n    if (index !== -1) {\n      this.riskListeners.splice(index, 1);\n    }\n  }\n\n  /**\n   * 通知監聽器\n   */\n  private notifyListeners(assessment: RiskAssessment): void {\n    for (const listener of this.riskListeners) {\n      try {\n        listener(assessment);\n      } catch (error) {\n        console.error('[Risk Manager] Error in listener:', error);\n      }\n    }\n  }\n\n  /**\n   * 獲取統計信息\n   */\n  getStats() {\n    return {\n      users: this.userRiskProfiles.size,\n      assessments: Array.from(this.userRiskProfiles.values()).reduce((sum, profiles) => sum + profiles.length, 0),\n      alerts: Array.from(this.riskAlerts.values()).reduce((sum, alerts) => sum + alerts.length, 0),\n    };\n  }\n}\n\n// 導出單例\nexport const riskManager = new RiskManager();\n
