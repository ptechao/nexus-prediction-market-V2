/**\n * Recommendation Service\n * \n * 推薦系統：基於用戶行為、市場數據、社交關係的智能推薦\n */\n\nimport Decimal from 'decimal.js';\n\n/**\n * 推薦類型\n */\nexport enum RecommendationType {\n  MARKET = 'market',\n  TRADER = 'trader',\n  VAULT = 'vault',\n  STREAM = 'stream',\n}\n\n/**\n * 推薦項\n */\nexport interface Recommendation {\n  id: string;\n  userId: string;\n  type: RecommendationType;\n  targetId: string;\n  score: Decimal;\n  reason: string;\n  createdAt: number;\n}\n\n/**\n * 用戶行為記錄\n */\nexport interface UserBehavior {\n  userId: string;\n  action: 'view' | 'trade' | 'like' | 'follow' | 'share' | 'comment';\n  targetType: 'market' | 'trader' | 'vault' | 'stream';\n  targetId: string;\n  timestamp: number;\n  weight: Decimal;\n}\n\n/**\n * 用戶偏好\n */\nexport interface UserPreference {\n  userId: string;\n  category: string;\n  score: Decimal; // 0-100\n  updatedAt: number;\n}\n\n/**\n * Recommendation Service\n */\nexport class RecommendationService {\n  private recommendations: Map<string, Recommendation> = new Map();\n  private behaviors: UserBehavior[] = [];\n  private preferences: Map<string, UserPreference[]> = new Map();\n  private similarityCache: Map<string, Map<string, Decimal>> = new Map();\n  private cacheTimeout: number = 60 * 60 * 1000; // 1 小時\n\n  /**\n   * 記錄用戶行為\n   */\n  recordBehavior(\n    userId: string,\n    action: 'view' | 'trade' | 'like' | 'follow' | 'share' | 'comment',\n    targetType: 'market' | 'trader' | 'vault' | 'stream',\n    targetId: string\n  ): void {\n    // 計算行為權重\n    const weights: Record<string, number> = {\n      view: 1,\n      like: 3,\n      follow: 5,\n      trade: 10,\n      share: 7,\n      comment: 4,\n    };\n\n    const behavior: UserBehavior = {\n      userId,\n      action,\n      targetType,\n      targetId,\n      timestamp: Date.now(),\n      weight: new Decimal(weights[action] || 1),\n    };\n\n    this.behaviors.push(behavior);\n\n    // 更新用戶偏好\n    this.updateUserPreference(userId, targetType, weights[action] || 1);\n  }\n\n  /**\n   * 更新用戶偏好\n   */\n  private updateUserPreference(userId: string, category: string, weight: number): void {\n    const preferences = this.preferences.get(userId) || [];\n    const existing = preferences.find((p) => p.category === category);\n\n    if (existing) {\n      // 更新現有偏好（使用移動平均）\n      const newScore = existing.score.times(0.7).plus(new Decimal(weight).times(0.3));\n      existing.score = newScore.min(new Decimal(100));\n      existing.updatedAt = Date.now();\n    } else {\n      // 創建新偏好\n      preferences.push({\n        userId,\n        category,\n        score: new Decimal(Math.min(weight, 100)),\n        updatedAt: Date.now(),\n      });\n    }\n\n    this.preferences.set(userId, preferences);\n  }\n\n  /**\n   * 獲取市場推薦\n   */\n  getMarketRecommendations(\n    userId: string,\n    limit: number = 10,\n    allMarkets?: any[]\n  ): Recommendation[] {\n    const recommendations: Recommendation[] = [];\n    const userPreferences = this.preferences.get(userId) || [];\n\n    if (!allMarkets || allMarkets.length === 0) {\n      return recommendations;\n    }\n\n    // 計算每個市場的推薦分數\n    const scores: Map<string, Decimal> = new Map();\n\n    for (const market of allMarkets) {\n      let score = new Decimal(0);\n\n      // 1. 基於用戶偏好的分數\n      const preference = userPreferences.find((p) => p.category === market.category);\n      if (preference) {\n        score = score.plus(preference.score.times(0.4));\n      }\n\n      // 2. 基於市場熱度的分數\n      const popularity = Math.min(market.viewerCount || 0, 1000) / 10; // 0-100\n      score = score.plus(new Decimal(popularity).times(0.3));\n\n      // 3. 基於市場流動性的分數\n      const liquidity = Math.min(market.liquidity || 0, 1000000) / 10000; // 0-100\n      score = score.plus(new Decimal(liquidity).times(0.2));\n\n      // 4. 基於用戶與市場創建者的關係\n      const isFollowing = this.isUserFollowing(userId, market.creatorId);\n      if (isFollowing) {\n        score = score.plus(new Decimal(15));\n      }\n\n      scores.set(market.id, score);\n    }\n\n    // 排序並生成推薦\n    const sorted = Array.from(scores.entries())\n      .sort((a, b) => b[1].cmp(a[1]))\n      .slice(0, limit);\n\n    for (const [marketId, score] of sorted) {\n      const market = allMarkets.find((m) => m.id === marketId);\n      if (!market) continue;\n\n      const recommendationId = `rec-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n      const recommendation: Recommendation = {\n        id: recommendationId,\n        userId,\n        type: RecommendationType.MARKET,\n        targetId: marketId,\n        score: score.min(new Decimal(100)),\n        reason: this.generateRecommendationReason(market, userPreferences),\n        createdAt: Date.now(),\n      };\n\n      recommendations.push(recommendation);\n      this.recommendations.set(recommendationId, recommendation);\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * 獲取交易者推薦\n   */\n  getTraderRecommendations(\n    userId: string,\n    limit: number = 10,\n    allTraders?: any[]\n  ): Recommendation[] {\n    const recommendations: Recommendation[] = [];\n\n    if (!allTraders || allTraders.length === 0) {\n      return recommendations;\n    }\n\n    // 計算每個交易者的推薦分數\n    const scores: Map<string, Decimal> = new Map();\n\n    for (const trader of allTraders) {\n      let score = new Decimal(0);\n\n      // 1. 基於交易者的勝率\n      const winRate = new Decimal(trader.winRate || 0).min(new Decimal(100));\n      score = score.plus(winRate.times(0.4));\n\n      // 2. 基於交易者的收益率\n      const returnRate = Math.min(trader.avgReturn || 0, 100);\n      score = score.plus(new Decimal(returnRate).times(0.3));\n\n      // 3. 基於交易者的粉絲數\n      const followers = Math.min(trader.followers || 0, 10000) / 100; // 0-100\n      score = score.plus(new Decimal(followers).times(0.2));\n\n      // 4. 基於用戶與交易者的關係\n      const isFollowing = this.isUserFollowing(userId, trader.id);\n      if (isFollowing) {\n        score = score.plus(new Decimal(10));\n      }\n\n      scores.set(trader.id, score);\n    }\n\n    // 排序並生成推薦\n    const sorted = Array.from(scores.entries())\n      .sort((a, b) => b[1].cmp(a[1]))\n      .slice(0, limit);\n\n    for (const [traderId, score] of sorted) {\n      const trader = allTraders.find((t) => t.id === traderId);\n      if (!trader) continue;\n\n      const recommendationId = `rec-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n      const recommendation: Recommendation = {\n        id: recommendationId,\n        userId,\n        type: RecommendationType.TRADER,\n        targetId: traderId,\n        score: score.min(new Decimal(100)),\n        reason: `Top trader with ${trader.winRate}% win rate and ${trader.followers} followers`,\n        createdAt: Date.now(),\n      };\n\n      recommendations.push(recommendation);\n      this.recommendations.set(recommendationId, recommendation);\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * 獲取 Vault 推薦\n   */\n  getVaultRecommendations(\n    userId: string,\n    limit: number = 10,\n    allVaults?: any[]\n  ): Recommendation[] {\n    const recommendations: Recommendation[] = [];\n\n    if (!allVaults || allVaults.length === 0) {\n      return recommendations;\n    }\n\n    // 計算每個 Vault 的推薦分數\n    const scores: Map<string, Decimal> = new Map();\n\n    for (const vault of allVaults) {\n      let score = new Decimal(0);\n\n      // 1. 基於 Vault 的性能\n      const performance = Math.min(vault.performance || 0, 100);\n      score = score.plus(new Decimal(performance).times(0.4));\n\n      // 2. 基於 Vault 的資產規模\n      const aum = Math.min(vault.aum || 0, 10000000) / 100000; // 0-100\n      score = score.plus(new Decimal(aum).times(0.3));\n\n      // 3. 基於 Vault 的投資者數\n      const investors = Math.min(vault.investors || 0, 1000) / 10; // 0-100\n      score = score.plus(new Decimal(investors).times(0.2));\n\n      // 4. 基於用戶與 Vault 管理者的關係\n      const isFollowing = this.isUserFollowing(userId, vault.managerId);\n      if (isFollowing) {\n        score = score.plus(new Decimal(10));\n      }\n\n      scores.set(vault.id, score);\n    }\n\n    // 排序並生成推薦\n    const sorted = Array.from(scores.entries())\n      .sort((a, b) => b[1].cmp(a[1]))\n      .slice(0, limit);\n\n    for (const [vaultId, score] of sorted) {\n      const vault = allVaults.find((v) => v.id === vaultId);\n      if (!vault) continue;\n\n      const recommendationId = `rec-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n      const recommendation: Recommendation = {\n        id: recommendationId,\n        userId,\n        type: RecommendationType.VAULT,\n        targetId: vaultId,\n        score: score.min(new Decimal(100)),\n        reason: `High-performing vault with ${vault.performance}% annual return`,\n        createdAt: Date.now(),\n      };\n\n      recommendations.push(recommendation);\n      this.recommendations.set(recommendationId, recommendation);\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * 獲取直播推薦\n   */\n  getStreamRecommendations(\n    userId: string,\n    limit: number = 10,\n    allStreams?: any[]\n  ): Recommendation[] {\n    const recommendations: Recommendation[] = [];\n\n    if (!allStreams || allStreams.length === 0) {\n      return recommendations;\n    }\n\n    // 計算每個直播的推薦分數\n    const scores: Map<string, Decimal> = new Map();\n\n    for (const stream of allStreams) {\n      let score = new Decimal(0);\n\n      // 1. 基於直播的觀眾數\n      const viewers = Math.min(stream.viewerCount || 0, 10000) / 100; // 0-100\n      score = score.plus(new Decimal(viewers).times(0.4));\n\n      // 2. 基於直播的點贊數\n      const likes = Math.min(stream.likeCount || 0, 1000) / 10; // 0-100\n      score = score.plus(new Decimal(likes).times(0.3));\n\n      // 3. 基於直播的分類匹配\n      const preference = this.preferences.get(userId)?.find((p) => p.category === stream.category);\n      if (preference) {\n        score = score.plus(preference.score.times(0.2));\n      }\n\n      // 4. 基於用戶與主播的關係\n      const isFollowing = this.isUserFollowing(userId, stream.hostId);\n      if (isFollowing) {\n        score = score.plus(new Decimal(15));\n      }\n\n      scores.set(stream.id, score);\n    }\n\n    // 排序並生成推薦\n    const sorted = Array.from(scores.entries())\n      .sort((a, b) => b[1].cmp(a[1]))\n      .slice(0, limit);\n\n    for (const [streamId, score] of sorted) {\n      const stream = allStreams.find((s) => s.id === streamId);\n      if (!stream) continue;\n\n      const recommendationId = `rec-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n      const recommendation: Recommendation = {\n        id: recommendationId,\n        userId,\n        type: RecommendationType.STREAM,\n        targetId: streamId,\n        score: score.min(new Decimal(100)),\n        reason: `Popular ${stream.category} stream with ${stream.viewerCount} viewers`,\n        createdAt: Date.now(),\n      };\n\n      recommendations.push(recommendation);\n      this.recommendations.set(recommendationId, recommendation);\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * 生成推薦理由\n   */\n  private generateRecommendationReason(market: any, userPreferences: UserPreference[]): string {\n    const preference = userPreferences.find((p) => p.category === market.category);\n    if (preference) {\n      return `Based on your interest in ${market.category} markets`;\n    }\n    return `Popular market in ${market.category} category`;\n  }\n\n  /**\n   * 檢查用戶是否關注\n   */\n  private isUserFollowing(userId: string, targetId: string): boolean {\n    // 這裡應該查詢社交服務\n    // 暫時返回 false\n    return false;\n  }\n\n  /**\n   * 獲取用戶偏好\n   */\n  getUserPreferences(userId: string): UserPreference[] {\n    return this.preferences.get(userId) || [];\n  }\n\n  /**\n   * 獲取推薦\n   */\n  getRecommendation(recommendationId: string): Recommendation | null {\n    return this.recommendations.get(recommendationId) || null;\n  }\n\n  /**\n   * 清理過期行為記錄\n   */\n  cleanupOldBehaviors(daysOld: number = 30): void {\n    const cutoffTime = Date.now() - daysOld * 24 * 60 * 60 * 1000;\n    this.behaviors = this.behaviors.filter((b) => b.timestamp > cutoffTime);\n  }\n\n  /**\n   * 獲取統計信息\n   */\n  getStats() {\n    return {\n      totalBehaviors: this.behaviors.length,\n      totalRecommendations: this.recommendations.size,\n      totalPreferences: this.preferences.size,\n      averageBehaviorsPerUser: this.behaviors.length / Math.max(this.preferences.size, 1),\n    };\n  }\n}\n\n// 導出單例\nexport const recommendationService = new RecommendationService();\n
