/**\n * Market Parser æœå‹™\n * \n * å¸‚å ´æ•¸æ“šè§£æã€å¸‚å ´å…ƒæ•¸æ“šæå–ã€å¸‚å ´åˆ†é¡ã€å¸‚å ´æœç´¢\n */\n\n/**\n * è§£æçš„å¸‚å ´æ•¸æ“š\n */\ninterface ParsedMarket {\n  id: string;\n  title: string;\n  description: string;\n  category: string;\n  tags: string[];\n  keywords: string[];\n  sentiment: 'bullish' | 'bearish' | 'neutral';\n  complexity: 'simple' | 'medium' | 'complex';\n  trustScore: number; // 0-100\n  metadata: {\n    source: string;\n    sourceUrl?: string;\n    fetchedAt: number;\n    expiresAt: number;\n  };\n}\n\n/**\n * å¸‚å ´åˆ†é¡\n */\ninterface MarketCategory {\n  name: string;\n  keywords: string[];\n  subcategories?: string[];\n  emoji?: string;\n}\n\n/**\n * å¸‚å ´æœç´¢çµæœ\n */\ninterface SearchResult {\n  marketId: string;\n  title: string;\n  relevance: number; // 0-100\n  category: string;\n  tags: string[];\n}\n\n/**\n * Market Parser æœå‹™\n */\nclass MarketParser {\n  private categories: Map<string, MarketCategory> = new Map();\n  private marketCache: Map<string, ParsedMarket> = new Map();\n  private cacheTTL: number = 24 * 60 * 60 * 1000; // 24 å°æ™‚\n  private keywords: Map<string, string[]> = new Map(); // é—œéµè©åˆ°åˆ†é¡çš„æ˜ å°„\n\n  constructor() {\n    this.initializeCategories();\n    this.initializeKeywords();\n  }\n\n  /**\n   * åˆå§‹åŒ–å¸‚å ´åˆ†é¡\n   */\n  private initializeCategories(): void {\n    const categories: MarketCategory[] = [\n      {\n        name: 'Crypto',\n        keywords: ['bitcoin', 'ethereum', 'crypto', 'blockchain', 'web3', 'defi', 'nft'],\n        subcategories: ['Bitcoin', 'Ethereum', 'DeFi', 'Layer2', 'Altcoins'],\n        emoji: 'â‚¿',\n      },\n      {\n        name: 'Sports',\n        keywords: ['nba', 'nfl', 'soccer', 'football', 'basketball', 'sports', 'game', 'match', 'championship'],\n        subcategories: ['NBA', 'NFL', 'Soccer', 'Tennis', 'Golf'],\n        emoji: 'ğŸ€',\n      },\n      {\n        name: 'Politics',\n        keywords: ['election', 'political', 'politics', 'vote', 'candidate', 'president', 'congress', 'senate'],\n        subcategories: ['US Elections', 'International', 'Policy'],\n        emoji: 'ğŸ—³ï¸',\n      },\n      {\n        name: 'Finance',\n        keywords: ['stock', 'market', 'economy', 'finance', 'gdp', 'inflation', 'interest', 'rate', 'sp500'],\n        subcategories: ['Stock Market', 'Forex', 'Commodities', 'Bonds'],\n        emoji: 'ğŸ“ˆ',\n      },\n      {\n        name: 'Technology',\n        keywords: ['tech', 'technology', 'ai', 'artificial intelligence', 'software', 'hardware', 'startup'],\n        subcategories: ['AI', 'Cloud', 'Cybersecurity', 'Quantum'],\n        emoji: 'ğŸ’»',\n      },\n      {\n        name: 'Weather',\n        keywords: ['weather', 'temperature', 'climate', 'hurricane', 'snow', 'rain', 'storm'],\n        subcategories: ['Temperature', 'Precipitation', 'Extreme Weather'],\n        emoji: 'ğŸŒ¤ï¸',\n      },\n      {\n        name: 'Entertainment',\n        keywords: ['movie', 'music', 'award', 'celebrity', 'entertainment', 'oscar', 'grammy', 'box office'],\n        subcategories: ['Movies', 'Music', 'Awards', 'TV'],\n        emoji: 'ğŸ¬',\n      },\n      {\n        name: 'Science',\n        keywords: ['science', 'research', 'discovery', 'space', 'nasa', 'physics', 'biology'],\n        subcategories: ['Space', 'Medicine', 'Physics', 'Biology'],\n        emoji: 'ğŸ”¬',\n      },\n    ];\n\n    for (const category of categories) {\n      this.categories.set(category.name, category);\n    }\n  }\n\n  /**\n   * åˆå§‹åŒ–é—œéµè©æ˜ å°„\n   */\n  private initializeKeywords(): void {\n    for (const [categoryName, category] of this.categories) {\n      for (const keyword of category.keywords) {\n        if (!this.keywords.has(keyword.toLowerCase())) {\n          this.keywords.set(keyword.toLowerCase(), []);\n        }\n        this.keywords.get(keyword.toLowerCase())!.push(categoryName);\n      }\n    }\n  }\n\n  /**\n   * è§£æå¸‚å ´æ•¸æ“š\n   */\n  parseMarket(\n    id: string,\n    title: string,\n    description: string,\n    source: string = 'custom'\n  ): ParsedMarket {\n    // æª¢æŸ¥ç·©å­˜\n    const cached = this.marketCache.get(id);\n    if (cached && Date.now() - cached.metadata.fetchedAt < this.cacheTTL) {\n      return cached;\n    }\n\n    // æå–é—œéµè©\n    const keywords = this.extractKeywords(title, description);\n\n    // åˆ†é¡å¸‚å ´\n    const category = this.classifyMarket(title, description, keywords);\n\n    // æå–æ¨™ç±¤\n    const tags = this.extractTags(title, description, category);\n\n    // åˆ†ææƒ…æ„Ÿ\n    const sentiment = this.analyzeSentiment(title, description);\n\n    // è©•ä¼°è¤‡é›œåº¦\n    const complexity = this.assessComplexity(title, description);\n\n    // è¨ˆç®—ä¿¡ä»»åˆ†æ•¸\n    const trustScore = this.calculateTrustScore(title, description, keywords);\n\n    const parsed: ParsedMarket = {\n      id,\n      title,\n      description,\n      category,\n      tags,\n      keywords,\n      sentiment,\n      complexity,\n      trustScore,\n      metadata: {\n        source,\n        fetchedAt: Date.now(),\n        expiresAt: Date.now() + this.cacheTTL,\n      },\n    };\n\n    // ç·©å­˜çµæœ\n    this.marketCache.set(id, parsed);\n\n    return parsed;\n  }\n\n  /**\n   * æå–é—œéµè©\n   */\n  private extractKeywords(title: string, description: string): string[] {\n    const text = (title + ' ' + description).toLowerCase();\n    const words = text.split(/\\s+/);\n    const keywords: Set<string> = new Set();\n\n    for (const word of words) {\n      // ç§»é™¤æ¨™é»ç¬¦è™Ÿ\n      const cleanWord = word.replace(/[^a-z0-9]/g, '');\n\n      // æª¢æŸ¥æ˜¯å¦æ˜¯å·²çŸ¥é—œéµè©\n      if (this.keywords.has(cleanWord) && cleanWord.length > 2) {\n        keywords.add(cleanWord);\n      }\n    }\n\n    return Array.from(keywords);\n  }\n\n  /**\n   * åˆ†é¡å¸‚å ´\n   */\n  private classifyMarket(title: string, description: string, keywords: string[]): string {\n    // åŸºæ–¼é—œéµè©çš„åˆ†é¡\n    const categoryScores: Map<string, number> = new Map();\n\n    for (const keyword of keywords) {\n      const categories = this.keywords.get(keyword) || [];\n      for (const category of categories) {\n        categoryScores.set(category, (categoryScores.get(category) || 0) + 2);\n      }\n    }\n\n    // åŸºæ–¼æ¨™é¡Œçš„åˆ†é¡\n    const titleLower = title.toLowerCase();\n    for (const [keyword, categories] of this.keywords) {\n      if (titleLower.includes(keyword)) {\n        for (const category of categories) {\n          categoryScores.set(category, (categoryScores.get(category) || 0) + 3);\n        }\n      }\n    }\n\n    // æ‰¾åˆ°æœ€é«˜åˆ†çš„åˆ†é¡\n    let bestCategory = 'Other';\n    let bestScore = 0;\n    for (const [category, score] of categoryScores) {\n      if (score > bestScore) {\n        bestScore = score;\n        bestCategory = category;\n      }\n    }\n\n    return bestCategory;\n  }\n\n  /**\n   * æå–æ¨™ç±¤\n   */\n  private extractTags(title: string, description: string, category: string): string[] {\n    const tags: Set<string> = new Set();\n\n    // æ·»åŠ åˆ†é¡ä½œç‚ºæ¨™ç±¤\n    tags.add(category);\n\n    // æå–ç‰¹å®šçš„æ¨™ç±¤\n    const tagPatterns = [\n      /\\b(bitcoin|btc|ethereum|eth|crypto|nft|defi)\\b/gi,\n      /\\b(nba|nfl|soccer|football|basketball|sports)\\b/gi,\n      /\\b(election|political|politics|vote)\\b/gi,\n      /\\b(stock|market|economy|finance)\\b/gi,\n      /\\b(ai|artificial intelligence|machine learning)\\b/gi,\n    ];\n\n    const text = title + ' ' + description;\n    for (const pattern of tagPatterns) {\n      const matches = text.match(pattern);\n      if (matches) {\n        for (const match of matches) {\n          tags.add(match.toLowerCase());\n        }\n      }\n    }\n\n    return Array.from(tags).slice(0, 10); // æœ€å¤š 10 å€‹æ¨™ç±¤\n  }\n\n  /**\n   * åˆ†ææƒ…æ„Ÿ\n   */\n  private analyzeSentiment(title: string, description: string): 'bullish' | 'bearish' | 'neutral' {\n    const text = (title + ' ' + description).toLowerCase();\n\n    const bullishWords = ['up', 'rise', 'gain', 'win', 'success', 'growth', 'bull', 'positive', 'above', 'exceed'];\n    const bearishWords = ['down', 'fall', 'loss', 'fail', 'decline', 'bear', 'negative', 'below', 'under'];\n\n    let bullishScore = 0;\n    let bearishScore = 0;\n\n    for (const word of bullishWords) {\n      if (text.includes(word)) bullishScore++;\n    }\n\n    for (const word of bearishWords) {\n      if (text.includes(word)) bearishScore++;\n    }\n\n    if (bullishScore > bearishScore) return 'bullish';\n    if (bearishScore > bullishScore) return 'bearish';\n    return 'neutral';\n  }\n\n  /**\n   * è©•ä¼°è¤‡é›œåº¦\n   */\n  private assessComplexity(title: string, description: string): 'simple' | 'medium' | 'complex' {\n    const text = title + ' ' + description;\n    const wordCount = text.split(/\\s+/).length;\n    const sentenceCount = text.split(/[.!?]+/).length;\n    const averageWordLength = text.replace(/\\s/g, '').length / wordCount;\n\n    // åŸºæ–¼æ–‡æœ¬è¤‡é›œåº¦è©•ä¼°\n    if (wordCount < 20 && averageWordLength < 5) {\n      return 'simple';\n    } else if (wordCount < 50 && averageWordLength < 6) {\n      return 'medium';\n    } else {\n      return 'complex';\n    }\n  }\n\n  /**\n   * è¨ˆç®—ä¿¡ä»»åˆ†æ•¸\n   */\n  private calculateTrustScore(title: string, description: string, keywords: string[]): number {\n    let score = 50; // åŸºç¤åˆ†æ•¸\n\n    // åŸºæ–¼æ¨™é¡Œé•·åº¦\n    if (title.length > 10 && title.length < 200) score += 10;\n\n    // åŸºæ–¼æè¿°é•·åº¦\n    if (description.length > 50 && description.length < 5000) score += 15;\n\n    // åŸºæ–¼é—œéµè©æ•¸é‡\n    if (keywords.length > 2) score += 10;\n\n    // åŸºæ–¼æ˜¯å¦åŒ…å«å…·é«”ä¿¡æ¯\n    if (/\\d+/.test(title + description)) score += 5;\n\n    // åŸºæ–¼æ˜¯å¦åŒ…å«æ—¥æœŸ\n    if (/\\d{4}|january|february|march|april|may|june|july|august|september|october|november|december/i.test(\n      title + description\n    )) {\n      score += 10;\n    }\n\n    return Math.min(score, 100);\n  }\n\n  /**\n   * æœç´¢å¸‚å ´\n   */\n  searchMarkets(query: string, markets: ParsedMarket[]): SearchResult[] {\n    const queryLower = query.toLowerCase();\n    const results: SearchResult[] = [];\n\n    for (const market of markets) {\n      let relevance = 0;\n\n      // æ¨™é¡ŒåŒ¹é…\n      if (market.title.toLowerCase().includes(queryLower)) {\n        relevance += 40;\n      }\n\n      // æè¿°åŒ¹é…\n      if (market.description.toLowerCase().includes(queryLower)) {\n        relevance += 20;\n      }\n\n      // æ¨™ç±¤åŒ¹é…\n      for (const tag of market.tags) {\n        if (tag.toLowerCase().includes(queryLower)) {\n          relevance += 15;\n        }\n      }\n\n      // é—œéµè©åŒ¹é…\n      for (const keyword of market.keywords) {\n        if (keyword.toLowerCase().includes(queryLower)) {\n          relevance += 10;\n        }\n      }\n\n      if (relevance > 0) {\n        results.push({\n          marketId: market.id,\n          title: market.title,\n          relevance,\n          category: market.category,\n          tags: market.tags,\n        });\n      }\n    }\n\n    // æŒ‰ç›¸é—œæ€§æ’åº\n    return results.sort((a, b) => b.relevance - a.relevance);\n  }\n\n  /**\n   * ç²å–å¸‚å ´åˆ†é¡\n   */\n  getCategories(): MarketCategory[] {\n    return Array.from(this.categories.values());\n  }\n\n  /**\n   * æ¸…ç†ç·©å­˜\n   */\n  cleanupCache(): void {\n    const now = Date.now();\n    for (const [id, market] of this.marketCache) {\n      if (now > market.metadata.expiresAt) {\n        this.marketCache.delete(id);\n      }\n    }\n  }\n\n  /**\n   * ç²å–çµ±è¨ˆä¿¡æ¯\n   */\n  getStats() {\n    return {\n      categories: this.categories.size,\n      cachedMarkets: this.marketCache.size,\n      keywords: this.keywords.size,\n    };\n  }\n}\n\n// å°å‡ºå–®ä¾‹\nconst marketParser = new MarketParser();\n\nexport default marketParser;\nexport type { ParsedMarket, MarketCategory, SearchResult };\n
