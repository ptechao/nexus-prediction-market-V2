/**\n * 市場驗證器服務\n * \n * 驗證市場參數、狀態和其他相關信息\n */\n\nimport { ethers } from 'ethers';\n\n/**\n * 驗證結果\n */\ninterface ValidationResult {\n  valid: boolean;\n  errors: ValidationError[];\n  warnings: ValidationWarning[];\n}\n\n/**\n * 驗證錯誤\n */\ninterface ValidationError {\n  field: string;\n  message: string;\n  code: string;\n}\n\n/**\n * 驗證警告\n */\ninterface ValidationWarning {\n  field: string;\n  message: string;\n}\n\n/**\n * 市場參數\n */\ninterface MarketParams {\n  title: string;\n  description: string;\n  endDate: Date;\n  oracleAddress: string;\n  initialLiquidity: bigint;\n  category?: string;\n  tags?: string[];\n}\n\n/**\n * 市場狀態\n */\ninterface MarketState {\n  contractAddress: string;\n  status: string;\n  currentLiquidity: bigint;\n  totalVolume: bigint;\n  totalTrades: number;\n}\n\n/**\n * 市場驗證器\n */\nclass MarketValidator {\n  // Oracle 白名單\n  private oracleWhitelist: Set<string> = new Set([\n    '0x' + 'a'.repeat(40), // Chainlink\n    '0x' + 'b'.repeat(40), // Pyth\n    '0x' + 'c'.repeat(40), // Band Protocol\n  ]);\n\n  // 支持的分類\n  private supportedCategories: Set<string> = new Set([\n    'crypto',\n    'sports',\n    'politics',\n    'weather',\n    'entertainment',\n    'economics',\n    'technology',\n    'other',\n  ]);\n\n  // 最小和最大值\n  private readonly MIN_TITLE_LENGTH = 1;\n  private readonly MAX_TITLE_LENGTH = 256;\n  private readonly MIN_DESCRIPTION_LENGTH = 0;\n  private readonly MAX_DESCRIPTION_LENGTH = 5000;\n  private readonly MIN_END_DATE_OFFSET = 60 * 1000; // 1 分鐘\n  private readonly MAX_END_DATE_OFFSET = 365 * 24 * 60 * 60 * 1000; // 1 年\n  private readonly MIN_LIQUIDITY = 1n * 10n ** 15n; // 0.001 ETH\n  private readonly MAX_LIQUIDITY = 1000000n * 10n ** 18n; // 1M ETH\n\n  /**\n   * 驗證市場參數\n   */\n  validateMarketParams(params: MarketParams): ValidationResult {\n    const errors: ValidationError[] = [];\n    const warnings: ValidationWarning[] = [];\n\n    // 驗證標題\n    if (!params.title || params.title.trim().length === 0) {\n      errors.push({\n        field: 'title',\n        message: 'Title is required',\n        code: 'EMPTY_TITLE',\n      });\n    } else if (params.title.length < this.MIN_TITLE_LENGTH) {\n      errors.push({\n        field: 'title',\n        message: `Title must be at least ${this.MIN_TITLE_LENGTH} character(s)`,\n        code: 'TITLE_TOO_SHORT',\n      });\n    } else if (params.title.length > this.MAX_TITLE_LENGTH) {\n      errors.push({\n        field: 'title',\n        message: `Title must not exceed ${this.MAX_TITLE_LENGTH} characters`,\n        code: 'TITLE_TOO_LONG',\n      });\n    }\n\n    // 驗證描述\n    if (params.description && params.description.length > this.MAX_DESCRIPTION_LENGTH) {\n      errors.push({\n        field: 'description',\n        message: `Description must not exceed ${this.MAX_DESCRIPTION_LENGTH} characters`,\n        code: 'DESCRIPTION_TOO_LONG',\n      });\n    }\n\n    // 驗證結束時間\n    const now = Date.now();\n    const endTime = params.endDate.getTime();\n    const timeOffset = endTime - now;\n\n    if (endTime <= now) {\n      errors.push({\n        field: 'endDate',\n        message: 'End date must be in the future',\n        code: 'END_DATE_IN_PAST',\n      });\n    } else if (timeOffset < this.MIN_END_DATE_OFFSET) {\n      errors.push({\n        field: 'endDate',\n        message: `End date must be at least ${this.MIN_END_DATE_OFFSET / 1000} seconds in the future`,\n        code: 'END_DATE_TOO_SOON',\n      });\n    } else if (timeOffset > this.MAX_END_DATE_OFFSET) {\n      warnings.push({\n        field: 'endDate',\n        message: `End date is more than 1 year in the future`,\n      });\n    }\n\n    // 驗證 Oracle 地址\n    if (!params.oracleAddress) {\n      errors.push({\n        field: 'oracleAddress',\n        message: 'Oracle address is required',\n        code: 'EMPTY_ORACLE_ADDRESS',\n      });\n    } else if (!ethers.isAddress(params.oracleAddress)) {\n      errors.push({\n        field: 'oracleAddress',\n        message: 'Invalid Oracle address format',\n        code: 'INVALID_ORACLE_ADDRESS_FORMAT',\n      });\n    } else if (!this.isOracleWhitelisted(params.oracleAddress)) {\n      errors.push({\n        field: 'oracleAddress',\n        message: 'Oracle address is not in whitelist',\n        code: 'ORACLE_NOT_WHITELISTED',\n      });\n    }\n\n    // 驗證初始流動性\n    if (params.initialLiquidity < this.MIN_LIQUIDITY) {\n      errors.push({\n        field: 'initialLiquidity',\n        message: `Initial liquidity must be at least ${this.MIN_LIQUIDITY.toString()} Wei`,\n        code: 'LIQUIDITY_TOO_LOW',\n      });\n    } else if (params.initialLiquidity > this.MAX_LIQUIDITY) {\n      errors.push({\n        field: 'initialLiquidity',\n        message: `Initial liquidity must not exceed ${this.MAX_LIQUIDITY.toString()} Wei`,\n        code: 'LIQUIDITY_TOO_HIGH',\n      });\n    }\n\n    // 驗證分類\n    if (params.category && !this.supportedCategories.has(params.category)) {\n      errors.push({\n        field: 'category',\n        message: `Unsupported category: ${params.category}`,\n        code: 'UNSUPPORTED_CATEGORY',\n      });\n    }\n\n    // 驗證標籤\n    if (params.tags) {\n      if (params.tags.length > 10) {\n        errors.push({\n          field: 'tags',\n          message: 'Maximum 10 tags allowed',\n          code: 'TOO_MANY_TAGS',\n        });\n      }\n      for (const tag of params.tags) {\n        if (tag.length > 50) {\n          errors.push({\n            field: 'tags',\n            message: `Tag \"${tag}\" is too long (max 50 characters)`,\n            code: 'TAG_TOO_LONG',\n          });\n        }\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n      warnings,\n    };\n  }\n\n  /**\n   * 驗證市場狀態\n   */\n  validateMarketState(state: MarketState): ValidationResult {\n    const errors: ValidationError[] = [];\n    const warnings: ValidationWarning[] = [];\n\n    // 驗證合約地址\n    if (!ethers.isAddress(state.contractAddress)) {\n      errors.push({\n        field: 'contractAddress',\n        message: 'Invalid contract address',\n        code: 'INVALID_CONTRACT_ADDRESS',\n      });\n    }\n\n    // 驗證狀態\n    const validStatuses = ['active', 'closed', 'resolved', 'cancelled'];\n    if (!validStatuses.includes(state.status)) {\n      errors.push({\n        field: 'status',\n        message: `Invalid market status: ${state.status}`,\n        code: 'INVALID_STATUS',\n      });\n    }\n\n    // 驗證流動性\n    if (state.currentLiquidity < 0n) {\n      errors.push({\n        field: 'currentLiquidity',\n        message: 'Liquidity cannot be negative',\n        code: 'NEGATIVE_LIQUIDITY',\n      });\n    }\n\n    // 驗證交易量\n    if (state.totalVolume < 0n) {\n      errors.push({\n        field: 'totalVolume',\n        message: 'Total volume cannot be negative',\n        code: 'NEGATIVE_VOLUME',\n      });\n    }\n\n    // 驗證交易數\n    if (state.totalTrades < 0) {\n      errors.push({\n        field: 'totalTrades',\n        message: 'Total trades cannot be negative',\n        code: 'NEGATIVE_TRADES',\n      });\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n      warnings,\n    };\n  }\n\n  /**\n   * 驗證 Oracle 地址\n   */\n  validateOracleAddress(address: string): boolean {\n    if (!ethers.isAddress(address)) {\n      return false;\n    }\n    return this.isOracleWhitelisted(address);\n  }\n\n  /**\n   * 檢查 Oracle 是否在白名單中\n   */\n  private isOracleWhitelisted(address: string): boolean {\n    const normalized = ethers.getAddress(address);\n    return this.oracleWhitelist.has(normalized);\n  }\n\n  /**\n   * 添加 Oracle 到白名單\n   */\n  addOracleToWhitelist(address: string): void {\n    if (!ethers.isAddress(address)) {\n      throw new Error('Invalid address format');\n    }\n    const normalized = ethers.getAddress(address);\n    this.oracleWhitelist.add(normalized);\n  }\n\n  /**\n   * 從白名單中移除 Oracle\n   */\n  removeOracleFromWhitelist(address: string): void {\n    const normalized = ethers.getAddress(address);\n    this.oracleWhitelist.delete(normalized);\n  }\n\n  /**\n   * 獲取 Oracle 白名單\n   */\n  getOracleWhitelist(): string[] {\n    return Array.from(this.oracleWhitelist);\n  }\n\n  /**\n   * 驗證合約字節碼\n   */\n  async validateContractBytecode(\n    provider: ethers.Provider,\n    contractAddress: string,\n    expectedBytecodeHash: string\n  ): Promise<boolean> {\n    try {\n      const code = await provider.getCode(contractAddress);\n      if (code === '0x') {\n        return false; // 地址沒有代碼\n      }\n\n      // 計算字節碼哈希\n      const codeHash = ethers.keccak256(code);\n      return codeHash === expectedBytecodeHash;\n    } catch (error) {\n      console.error('Error validating bytecode:', error);\n      return false;\n    }\n  }\n\n  /**\n   * 驗證市場結束時間\n   */\n  validateEndDate(endDate: Date): ValidationResult {\n    const errors: ValidationError[] = [];\n    const warnings: ValidationWarning[] = [];\n\n    const now = Date.now();\n    const endTime = endDate.getTime();\n    const timeOffset = endTime - now;\n\n    if (endTime <= now) {\n      errors.push({\n        field: 'endDate',\n        message: 'End date must be in the future',\n        code: 'END_DATE_IN_PAST',\n      });\n    } else if (timeOffset < this.MIN_END_DATE_OFFSET) {\n      errors.push({\n        field: 'endDate',\n        message: `End date must be at least ${this.MIN_END_DATE_OFFSET / 1000} seconds in the future`,\n        code: 'END_DATE_TOO_SOON',\n      });\n    } else if (timeOffset > this.MAX_END_DATE_OFFSET) {\n      warnings.push({\n        field: 'endDate',\n        message: 'End date is more than 1 year in the future',\n      });\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n      warnings,\n    };\n  }\n\n  /**\n   * 驗證流動性\n   */\n  validateLiquidity(liquidity: bigint): ValidationResult {\n    const errors: ValidationError[] = [];\n    const warnings: ValidationWarning[] = [];\n\n    if (liquidity < this.MIN_LIQUIDITY) {\n      errors.push({\n        field: 'liquidity',\n        message: `Liquidity must be at least ${this.MIN_LIQUIDITY.toString()} Wei`,\n        code: 'LIQUIDITY_TOO_LOW',\n      });\n    } else if (liquidity > this.MAX_LIQUIDITY) {\n      errors.push({\n        field: 'liquidity',\n        message: `Liquidity must not exceed ${this.MAX_LIQUIDITY.toString()} Wei`,\n        code: 'LIQUIDITY_TOO_HIGH',\n      });\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n      warnings,\n    };\n  }\n\n  /**\n   * 獲取支持的分類\n   */\n  getSupportedCategories(): string[] {\n    return Array.from(this.supportedCategories);\n  }\n}\n\n// 導出單例\nconst marketValidator = new MarketValidator();\n\nexport default marketValidator;\nexport type { ValidationResult, ValidationError, ValidationWarning, MarketParams, MarketState };\n
